// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/app/order/handler.OrderService -o order_service_mock.go -n OrderServiceMock -p mock

import (
	"sync"

	"context"
	"route256/loms/internal/order/model"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderServiceMock implements handler.OrderService
type OrderServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, order *model.Order) (o1 model.OrderID, err error)
	inspectFuncCreate   func(ctx context.Context, order *model.Order)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrderServiceMockCreate

	funcGetOrder          func(ctx context.Context, orderID model.OrderID) (op1 *model.Order, err error)
	inspectFuncGetOrder   func(ctx context.Context, orderID model.OrderID)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mOrderServiceMockGetOrder

	funcSetStatus          func(ctx context.Context, orderID model.OrderID, status model.Status) (err error)
	inspectFuncSetStatus   func(ctx context.Context, orderID model.OrderID, status model.Status)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderServiceMockSetStatus
}

// NewOrderServiceMock returns a mock for handler.OrderService
func NewOrderServiceMock(t minimock.Tester) *OrderServiceMock {
	m := &OrderServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOrderServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrderServiceMockCreateParams{}

	m.GetOrderMock = mOrderServiceMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*OrderServiceMockGetOrderParams{}

	m.SetStatusMock = mOrderServiceMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderServiceMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderServiceMockCreate struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockCreateExpectation
	expectations       []*OrderServiceMockCreateExpectation

	callArgs []*OrderServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderServiceMockCreateExpectation specifies expectation struct of the OrderService.Create
type OrderServiceMockCreateExpectation struct {
	mock      *OrderServiceMock
	params    *OrderServiceMockCreateParams
	paramPtrs *OrderServiceMockCreateParamPtrs
	results   *OrderServiceMockCreateResults
	Counter   uint64
}

// OrderServiceMockCreateParams contains parameters of the OrderService.Create
type OrderServiceMockCreateParams struct {
	ctx   context.Context
	order *model.Order
}

// OrderServiceMockCreateParamPtrs contains pointers to parameters of the OrderService.Create
type OrderServiceMockCreateParamPtrs struct {
	ctx   *context.Context
	order **model.Order
}

// OrderServiceMockCreateResults contains results of the OrderService.Create
type OrderServiceMockCreateResults struct {
	o1  model.OrderID
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrderServiceMockCreate) Optional() *mOrderServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for OrderService.Create
func (mmCreate *mOrderServiceMockCreate) Expect(ctx context.Context, order *model.Order) *mOrderServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OrderServiceMockCreateParams{ctx, order}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.Create
func (mmCreate *mOrderServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectOrderParam2 sets up expected param order for OrderService.Create
func (mmCreate *mOrderServiceMockCreate) ExpectOrderParam2(order *model.Order) *mOrderServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.order = &order

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the OrderService.Create
func (mmCreate *mOrderServiceMockCreate) Inspect(f func(ctx context.Context, order *model.Order)) *mOrderServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by OrderService.Create
func (mmCreate *mOrderServiceMockCreate) Return(o1 model.OrderID, err error) *OrderServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrderServiceMockCreateResults{o1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the OrderService.Create method
func (mmCreate *mOrderServiceMockCreate) Set(f func(ctx context.Context, order *model.Order) (o1 model.OrderID, err error)) *OrderServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the OrderService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the OrderService.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the OrderService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrderServiceMockCreate) When(ctx context.Context, order *model.Order) *OrderServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderServiceMock.Create mock is already set by Set")
	}

	expectation := &OrderServiceMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &OrderServiceMockCreateParams{ctx, order},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up OrderService.Create return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockCreateExpectation) Then(o1 model.OrderID, err error) *OrderServiceMock {
	e.results = &OrderServiceMockCreateResults{o1, err}
	return e.mock
}

// Times sets number of times OrderService.Create should be invoked
func (mmCreate *mOrderServiceMockCreate) Times(n uint64) *mOrderServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OrderServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mOrderServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements handler.OrderService
func (mmCreate *OrderServiceMock) Create(ctx context.Context, order *model.Order) (o1 model.OrderID, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, order)
	}

	mm_params := OrderServiceMockCreateParams{ctx, order}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockCreateParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OrderServiceMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmCreate.t.Errorf("OrderServiceMock.Create got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrderServiceMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrderServiceMock.Create")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, order)
	}
	mmCreate.t.Fatalf("Unexpected call to OrderServiceMock.Create. %v %v", ctx, order)
	return
}

// CreateAfterCounter returns a count of finished OrderServiceMock.Create invocations
func (mmCreate *OrderServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrderServiceMock.Create invocations
func (mmCreate *OrderServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrderServiceMockCreate) Calls() []*OrderServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrderServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderServiceMock.Create")
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to OrderServiceMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mOrderServiceMockGetOrder struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockGetOrderExpectation
	expectations       []*OrderServiceMockGetOrderExpectation

	callArgs []*OrderServiceMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderServiceMockGetOrderExpectation specifies expectation struct of the OrderService.GetOrder
type OrderServiceMockGetOrderExpectation struct {
	mock      *OrderServiceMock
	params    *OrderServiceMockGetOrderParams
	paramPtrs *OrderServiceMockGetOrderParamPtrs
	results   *OrderServiceMockGetOrderResults
	Counter   uint64
}

// OrderServiceMockGetOrderParams contains parameters of the OrderService.GetOrder
type OrderServiceMockGetOrderParams struct {
	ctx     context.Context
	orderID model.OrderID
}

// OrderServiceMockGetOrderParamPtrs contains pointers to parameters of the OrderService.GetOrder
type OrderServiceMockGetOrderParamPtrs struct {
	ctx     *context.Context
	orderID *model.OrderID
}

// OrderServiceMockGetOrderResults contains results of the OrderService.GetOrder
type OrderServiceMockGetOrderResults struct {
	op1 *model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mOrderServiceMockGetOrder) Optional() *mOrderServiceMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for OrderService.GetOrder
func (mmGetOrder *mOrderServiceMockGetOrder) Expect(ctx context.Context, orderID model.OrderID) *mOrderServiceMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderServiceMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderServiceMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("OrderServiceMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &OrderServiceMockGetOrderParams{ctx, orderID}
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.GetOrder
func (mmGetOrder *mOrderServiceMockGetOrder) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderServiceMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderServiceMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("OrderServiceMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &OrderServiceMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderService.GetOrder
func (mmGetOrder *mOrderServiceMockGetOrder) ExpectOrderIDParam2(orderID model.OrderID) *mOrderServiceMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderServiceMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderServiceMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("OrderServiceMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &OrderServiceMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.orderID = &orderID

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderService.GetOrder
func (mmGetOrder *mOrderServiceMockGetOrder) Inspect(f func(ctx context.Context, orderID model.OrderID)) *mOrderServiceMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by OrderService.GetOrder
func (mmGetOrder *mOrderServiceMockGetOrder) Return(op1 *model.Order, err error) *OrderServiceMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderServiceMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &OrderServiceMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &OrderServiceMockGetOrderResults{op1, err}
	return mmGetOrder.mock
}

// Set uses given function f to mock the OrderService.GetOrder method
func (mmGetOrder *mOrderServiceMockGetOrder) Set(f func(ctx context.Context, orderID model.OrderID) (op1 *model.Order, err error)) *OrderServiceMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the OrderService.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the OrderService.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	return mmGetOrder.mock
}

// When sets expectation for the OrderService.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mOrderServiceMockGetOrder) When(ctx context.Context, orderID model.OrderID) *OrderServiceMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("OrderServiceMock.GetOrder mock is already set by Set")
	}

	expectation := &OrderServiceMockGetOrderExpectation{
		mock:   mmGetOrder.mock,
		params: &OrderServiceMockGetOrderParams{ctx, orderID},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderService.GetOrder return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockGetOrderExpectation) Then(op1 *model.Order, err error) *OrderServiceMock {
	e.results = &OrderServiceMockGetOrderResults{op1, err}
	return e.mock
}

// Times sets number of times OrderService.GetOrder should be invoked
func (mmGetOrder *mOrderServiceMockGetOrder) Times(n uint64) *mOrderServiceMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of OrderServiceMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	return mmGetOrder
}

func (mmGetOrder *mOrderServiceMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements handler.OrderService
func (mmGetOrder *OrderServiceMock) GetOrder(ctx context.Context, orderID model.OrderID) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, orderID)
	}

	mm_params := OrderServiceMockGetOrderParams{ctx, orderID}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockGetOrderParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrder.t.Errorf("OrderServiceMock.GetOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetOrder.t.Errorf("OrderServiceMock.GetOrder got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("OrderServiceMock.GetOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the OrderServiceMock.GetOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, orderID)
	}
	mmGetOrder.t.Fatalf("Unexpected call to OrderServiceMock.GetOrder. %v %v", ctx, orderID)
	return
}

// GetOrderAfterCounter returns a count of finished OrderServiceMock.GetOrder invocations
func (mmGetOrder *OrderServiceMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of OrderServiceMock.GetOrder invocations
func (mmGetOrder *OrderServiceMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mOrderServiceMockGetOrder) Calls() []*OrderServiceMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*OrderServiceMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.GetOrder with params: %#v", *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderServiceMock.GetOrder")
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.GetOrder with params: %#v", *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Error("Expected call to OrderServiceMock.GetOrder")
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.GetOrder but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), afterGetOrderCounter)
	}
}

type mOrderServiceMockSetStatus struct {
	optional           bool
	mock               *OrderServiceMock
	defaultExpectation *OrderServiceMockSetStatusExpectation
	expectations       []*OrderServiceMockSetStatusExpectation

	callArgs []*OrderServiceMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderServiceMockSetStatusExpectation specifies expectation struct of the OrderService.SetStatus
type OrderServiceMockSetStatusExpectation struct {
	mock      *OrderServiceMock
	params    *OrderServiceMockSetStatusParams
	paramPtrs *OrderServiceMockSetStatusParamPtrs
	results   *OrderServiceMockSetStatusResults
	Counter   uint64
}

// OrderServiceMockSetStatusParams contains parameters of the OrderService.SetStatus
type OrderServiceMockSetStatusParams struct {
	ctx     context.Context
	orderID model.OrderID
	status  model.Status
}

// OrderServiceMockSetStatusParamPtrs contains pointers to parameters of the OrderService.SetStatus
type OrderServiceMockSetStatusParamPtrs struct {
	ctx     *context.Context
	orderID *model.OrderID
	status  *model.Status
}

// OrderServiceMockSetStatusResults contains results of the OrderService.SetStatus
type OrderServiceMockSetStatusResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrderServiceMockSetStatus) Optional() *mOrderServiceMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for OrderService.SetStatus
func (mmSetStatus *mOrderServiceMockSetStatus) Expect(ctx context.Context, orderID model.OrderID, status model.Status) *mOrderServiceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderServiceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderServiceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrderServiceMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrderServiceMockSetStatusParams{ctx, orderID, status}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for OrderService.SetStatus
func (mmSetStatus *mOrderServiceMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrderServiceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderServiceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderServiceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderServiceMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderServiceMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetStatus
}

// ExpectOrderIDParam2 sets up expected param orderID for OrderService.SetStatus
func (mmSetStatus *mOrderServiceMockSetStatus) ExpectOrderIDParam2(orderID model.OrderID) *mOrderServiceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderServiceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderServiceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderServiceMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderServiceMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.orderID = &orderID

	return mmSetStatus
}

// ExpectStatusParam3 sets up expected param status for OrderService.SetStatus
func (mmSetStatus *mOrderServiceMockSetStatus) ExpectStatusParam3(status model.Status) *mOrderServiceMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderServiceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderServiceMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderServiceMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderServiceMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.status = &status

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the OrderService.SetStatus
func (mmSetStatus *mOrderServiceMockSetStatus) Inspect(f func(ctx context.Context, orderID model.OrderID, status model.Status)) *mOrderServiceMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderServiceMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by OrderService.SetStatus
func (mmSetStatus *mOrderServiceMockSetStatus) Return(err error) *OrderServiceMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderServiceMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderServiceMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderServiceMockSetStatusResults{err}
	return mmSetStatus.mock
}

// Set uses given function f to mock the OrderService.SetStatus method
func (mmSetStatus *mOrderServiceMockSetStatus) Set(f func(ctx context.Context, orderID model.OrderID, status model.Status) (err error)) *OrderServiceMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the OrderService.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the OrderService.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// When sets expectation for the OrderService.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderServiceMockSetStatus) When(ctx context.Context, orderID model.OrderID, status model.Status) *OrderServiceMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderServiceMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderServiceMockSetStatusExpectation{
		mock:   mmSetStatus.mock,
		params: &OrderServiceMockSetStatusParams{ctx, orderID, status},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up OrderService.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderServiceMockSetStatusExpectation) Then(err error) *OrderServiceMock {
	e.results = &OrderServiceMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times OrderService.SetStatus should be invoked
func (mmSetStatus *mOrderServiceMockSetStatus) Times(n uint64) *mOrderServiceMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrderServiceMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	return mmSetStatus
}

func (mmSetStatus *mOrderServiceMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements handler.OrderService
func (mmSetStatus *OrderServiceMock) SetStatus(ctx context.Context, orderID model.OrderID, status model.Status) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, orderID, status)
	}

	mm_params := OrderServiceMockSetStatusParams{ctx, orderID, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderServiceMockSetStatusParams{ctx, orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrderServiceMock.SetStatus got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetStatus.t.Errorf("OrderServiceMock.SetStatus got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatus.t.Errorf("OrderServiceMock.SetStatus got unexpected parameter status, want: %#v, got: %#v%s\n", *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderServiceMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderServiceMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, orderID, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderServiceMock.SetStatus. %v %v %v", ctx, orderID, status)
	return
}

// SetStatusAfterCounter returns a count of finished OrderServiceMock.SetStatus invocations
func (mmSetStatus *OrderServiceMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderServiceMock.SetStatus invocations
func (mmSetStatus *OrderServiceMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderServiceMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderServiceMockSetStatus) Calls() []*OrderServiceMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderServiceMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderServiceMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderServiceMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderServiceMock.SetStatus with params: %#v", *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderServiceMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to OrderServiceMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Error("Expected call to OrderServiceMock.SetStatus")
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderServiceMock.SetStatus but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetOrderInspect()

			m.MinimockSetStatusInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockSetStatusDone()
}
