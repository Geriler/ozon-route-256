// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/app/stocks/handler.StocksService -o stocks_service_mock.go -n StocksServiceMock -p mock

import (
	"context"
	stocksModel "route256/loms/internal/stocks/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StocksServiceMock implements handler.StocksService
type StocksServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcStocksServiceGetBySKU          func(ctx context.Context, sku stocksModel.SKU) (sp1 *stocksModel.Stocks, err error)
	inspectFuncStocksServiceGetBySKU   func(ctx context.Context, sku stocksModel.SKU)
	afterStocksServiceGetBySKUCounter  uint64
	beforeStocksServiceGetBySKUCounter uint64
	StocksServiceGetBySKUMock          mStocksServiceMockStocksServiceGetBySKU

	funcStocksServiceReserve          func(ctx context.Context, sku stocksModel.SKU, count int64) (err error)
	inspectFuncStocksServiceReserve   func(ctx context.Context, sku stocksModel.SKU, count int64)
	afterStocksServiceReserveCounter  uint64
	beforeStocksServiceReserveCounter uint64
	StocksServiceReserveMock          mStocksServiceMockStocksServiceReserve

	funcStocksServiceReserveCancel          func(ctx context.Context, sku stocksModel.SKU, count int64) (err error)
	inspectFuncStocksServiceReserveCancel   func(ctx context.Context, sku stocksModel.SKU, count int64)
	afterStocksServiceReserveCancelCounter  uint64
	beforeStocksServiceReserveCancelCounter uint64
	StocksServiceReserveCancelMock          mStocksServiceMockStocksServiceReserveCancel

	funcStocksServiceReserveRemove          func(ctx context.Context, sku stocksModel.SKU, count int64) (err error)
	inspectFuncStocksServiceReserveRemove   func(ctx context.Context, sku stocksModel.SKU, count int64)
	afterStocksServiceReserveRemoveCounter  uint64
	beforeStocksServiceReserveRemoveCounter uint64
	StocksServiceReserveRemoveMock          mStocksServiceMockStocksServiceReserveRemove
}

// NewStocksServiceMock returns a mock for handler.StocksService
func NewStocksServiceMock(t minimock.Tester) *StocksServiceMock {
	m := &StocksServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.StocksServiceGetBySKUMock = mStocksServiceMockStocksServiceGetBySKU{mock: m}
	m.StocksServiceGetBySKUMock.callArgs = []*StocksServiceMockStocksServiceGetBySKUParams{}

	m.StocksServiceReserveMock = mStocksServiceMockStocksServiceReserve{mock: m}
	m.StocksServiceReserveMock.callArgs = []*StocksServiceMockStocksServiceReserveParams{}

	m.StocksServiceReserveCancelMock = mStocksServiceMockStocksServiceReserveCancel{mock: m}
	m.StocksServiceReserveCancelMock.callArgs = []*StocksServiceMockStocksServiceReserveCancelParams{}

	m.StocksServiceReserveRemoveMock = mStocksServiceMockStocksServiceReserveRemove{mock: m}
	m.StocksServiceReserveRemoveMock.callArgs = []*StocksServiceMockStocksServiceReserveRemoveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStocksServiceMockStocksServiceGetBySKU struct {
	optional           bool
	mock               *StocksServiceMock
	defaultExpectation *StocksServiceMockStocksServiceGetBySKUExpectation
	expectations       []*StocksServiceMockStocksServiceGetBySKUExpectation

	callArgs []*StocksServiceMockStocksServiceGetBySKUParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StocksServiceMockStocksServiceGetBySKUExpectation specifies expectation struct of the StocksService.StocksServiceGetBySKU
type StocksServiceMockStocksServiceGetBySKUExpectation struct {
	mock      *StocksServiceMock
	params    *StocksServiceMockStocksServiceGetBySKUParams
	paramPtrs *StocksServiceMockStocksServiceGetBySKUParamPtrs
	results   *StocksServiceMockStocksServiceGetBySKUResults
	Counter   uint64
}

// StocksServiceMockStocksServiceGetBySKUParams contains parameters of the StocksService.StocksServiceGetBySKU
type StocksServiceMockStocksServiceGetBySKUParams struct {
	ctx context.Context
	sku stocksModel.SKU
}

// StocksServiceMockStocksServiceGetBySKUParamPtrs contains pointers to parameters of the StocksService.StocksServiceGetBySKU
type StocksServiceMockStocksServiceGetBySKUParamPtrs struct {
	ctx *context.Context
	sku *stocksModel.SKU
}

// StocksServiceMockStocksServiceGetBySKUResults contains results of the StocksService.StocksServiceGetBySKU
type StocksServiceMockStocksServiceGetBySKUResults struct {
	sp1 *stocksModel.Stocks
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) Optional() *mStocksServiceMockStocksServiceGetBySKU {
	mmStocksServiceGetBySKU.optional = true
	return mmStocksServiceGetBySKU
}

// Expect sets up expected params for StocksService.StocksServiceGetBySKU
func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) Expect(ctx context.Context, sku stocksModel.SKU) *mStocksServiceMockStocksServiceGetBySKU {
	if mmStocksServiceGetBySKU.mock.funcStocksServiceGetBySKU != nil {
		mmStocksServiceGetBySKU.mock.t.Fatalf("StocksServiceMock.StocksServiceGetBySKU mock is already set by Set")
	}

	if mmStocksServiceGetBySKU.defaultExpectation == nil {
		mmStocksServiceGetBySKU.defaultExpectation = &StocksServiceMockStocksServiceGetBySKUExpectation{}
	}

	if mmStocksServiceGetBySKU.defaultExpectation.paramPtrs != nil {
		mmStocksServiceGetBySKU.mock.t.Fatalf("StocksServiceMock.StocksServiceGetBySKU mock is already set by ExpectParams functions")
	}

	mmStocksServiceGetBySKU.defaultExpectation.params = &StocksServiceMockStocksServiceGetBySKUParams{ctx, sku}
	for _, e := range mmStocksServiceGetBySKU.expectations {
		if minimock.Equal(e.params, mmStocksServiceGetBySKU.defaultExpectation.params) {
			mmStocksServiceGetBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocksServiceGetBySKU.defaultExpectation.params)
		}
	}

	return mmStocksServiceGetBySKU
}

// ExpectCtxParam1 sets up expected param ctx for StocksService.StocksServiceGetBySKU
func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) ExpectCtxParam1(ctx context.Context) *mStocksServiceMockStocksServiceGetBySKU {
	if mmStocksServiceGetBySKU.mock.funcStocksServiceGetBySKU != nil {
		mmStocksServiceGetBySKU.mock.t.Fatalf("StocksServiceMock.StocksServiceGetBySKU mock is already set by Set")
	}

	if mmStocksServiceGetBySKU.defaultExpectation == nil {
		mmStocksServiceGetBySKU.defaultExpectation = &StocksServiceMockStocksServiceGetBySKUExpectation{}
	}

	if mmStocksServiceGetBySKU.defaultExpectation.params != nil {
		mmStocksServiceGetBySKU.mock.t.Fatalf("StocksServiceMock.StocksServiceGetBySKU mock is already set by Expect")
	}

	if mmStocksServiceGetBySKU.defaultExpectation.paramPtrs == nil {
		mmStocksServiceGetBySKU.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceGetBySKUParamPtrs{}
	}
	mmStocksServiceGetBySKU.defaultExpectation.paramPtrs.ctx = &ctx

	return mmStocksServiceGetBySKU
}

// ExpectSkuParam2 sets up expected param sku for StocksService.StocksServiceGetBySKU
func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) ExpectSkuParam2(sku stocksModel.SKU) *mStocksServiceMockStocksServiceGetBySKU {
	if mmStocksServiceGetBySKU.mock.funcStocksServiceGetBySKU != nil {
		mmStocksServiceGetBySKU.mock.t.Fatalf("StocksServiceMock.StocksServiceGetBySKU mock is already set by Set")
	}

	if mmStocksServiceGetBySKU.defaultExpectation == nil {
		mmStocksServiceGetBySKU.defaultExpectation = &StocksServiceMockStocksServiceGetBySKUExpectation{}
	}

	if mmStocksServiceGetBySKU.defaultExpectation.params != nil {
		mmStocksServiceGetBySKU.mock.t.Fatalf("StocksServiceMock.StocksServiceGetBySKU mock is already set by Expect")
	}

	if mmStocksServiceGetBySKU.defaultExpectation.paramPtrs == nil {
		mmStocksServiceGetBySKU.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceGetBySKUParamPtrs{}
	}
	mmStocksServiceGetBySKU.defaultExpectation.paramPtrs.sku = &sku

	return mmStocksServiceGetBySKU
}

// Inspect accepts an inspector function that has same arguments as the StocksService.StocksServiceGetBySKU
func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) Inspect(f func(ctx context.Context, sku stocksModel.SKU)) *mStocksServiceMockStocksServiceGetBySKU {
	if mmStocksServiceGetBySKU.mock.inspectFuncStocksServiceGetBySKU != nil {
		mmStocksServiceGetBySKU.mock.t.Fatalf("Inspect function is already set for StocksServiceMock.StocksServiceGetBySKU")
	}

	mmStocksServiceGetBySKU.mock.inspectFuncStocksServiceGetBySKU = f

	return mmStocksServiceGetBySKU
}

// Return sets up results that will be returned by StocksService.StocksServiceGetBySKU
func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) Return(sp1 *stocksModel.Stocks, err error) *StocksServiceMock {
	if mmStocksServiceGetBySKU.mock.funcStocksServiceGetBySKU != nil {
		mmStocksServiceGetBySKU.mock.t.Fatalf("StocksServiceMock.StocksServiceGetBySKU mock is already set by Set")
	}

	if mmStocksServiceGetBySKU.defaultExpectation == nil {
		mmStocksServiceGetBySKU.defaultExpectation = &StocksServiceMockStocksServiceGetBySKUExpectation{mock: mmStocksServiceGetBySKU.mock}
	}
	mmStocksServiceGetBySKU.defaultExpectation.results = &StocksServiceMockStocksServiceGetBySKUResults{sp1, err}
	return mmStocksServiceGetBySKU.mock
}

// Set uses given function f to mock the StocksService.StocksServiceGetBySKU method
func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) Set(f func(ctx context.Context, sku stocksModel.SKU) (sp1 *stocksModel.Stocks, err error)) *StocksServiceMock {
	if mmStocksServiceGetBySKU.defaultExpectation != nil {
		mmStocksServiceGetBySKU.mock.t.Fatalf("Default expectation is already set for the StocksService.StocksServiceGetBySKU method")
	}

	if len(mmStocksServiceGetBySKU.expectations) > 0 {
		mmStocksServiceGetBySKU.mock.t.Fatalf("Some expectations are already set for the StocksService.StocksServiceGetBySKU method")
	}

	mmStocksServiceGetBySKU.mock.funcStocksServiceGetBySKU = f
	return mmStocksServiceGetBySKU.mock
}

// When sets expectation for the StocksService.StocksServiceGetBySKU which will trigger the result defined by the following
// Then helper
func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) When(ctx context.Context, sku stocksModel.SKU) *StocksServiceMockStocksServiceGetBySKUExpectation {
	if mmStocksServiceGetBySKU.mock.funcStocksServiceGetBySKU != nil {
		mmStocksServiceGetBySKU.mock.t.Fatalf("StocksServiceMock.StocksServiceGetBySKU mock is already set by Set")
	}

	expectation := &StocksServiceMockStocksServiceGetBySKUExpectation{
		mock:   mmStocksServiceGetBySKU.mock,
		params: &StocksServiceMockStocksServiceGetBySKUParams{ctx, sku},
	}
	mmStocksServiceGetBySKU.expectations = append(mmStocksServiceGetBySKU.expectations, expectation)
	return expectation
}

// Then sets up StocksService.StocksServiceGetBySKU return parameters for the expectation previously defined by the When method
func (e *StocksServiceMockStocksServiceGetBySKUExpectation) Then(sp1 *stocksModel.Stocks, err error) *StocksServiceMock {
	e.results = &StocksServiceMockStocksServiceGetBySKUResults{sp1, err}
	return e.mock
}

// Times sets number of times StocksService.StocksServiceGetBySKU should be invoked
func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) Times(n uint64) *mStocksServiceMockStocksServiceGetBySKU {
	if n == 0 {
		mmStocksServiceGetBySKU.mock.t.Fatalf("Times of StocksServiceMock.StocksServiceGetBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStocksServiceGetBySKU.expectedInvocations, n)
	return mmStocksServiceGetBySKU
}

func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) invocationsDone() bool {
	if len(mmStocksServiceGetBySKU.expectations) == 0 && mmStocksServiceGetBySKU.defaultExpectation == nil && mmStocksServiceGetBySKU.mock.funcStocksServiceGetBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStocksServiceGetBySKU.mock.afterStocksServiceGetBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStocksServiceGetBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StocksServiceGetBySKU implements handler.StocksService
func (mmStocksServiceGetBySKU *StocksServiceMock) StocksServiceGetBySKU(ctx context.Context, sku stocksModel.SKU) (sp1 *stocksModel.Stocks, err error) {
	mm_atomic.AddUint64(&mmStocksServiceGetBySKU.beforeStocksServiceGetBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmStocksServiceGetBySKU.afterStocksServiceGetBySKUCounter, 1)

	if mmStocksServiceGetBySKU.inspectFuncStocksServiceGetBySKU != nil {
		mmStocksServiceGetBySKU.inspectFuncStocksServiceGetBySKU(ctx, sku)
	}

	mm_params := StocksServiceMockStocksServiceGetBySKUParams{ctx, sku}

	// Record call args
	mmStocksServiceGetBySKU.StocksServiceGetBySKUMock.mutex.Lock()
	mmStocksServiceGetBySKU.StocksServiceGetBySKUMock.callArgs = append(mmStocksServiceGetBySKU.StocksServiceGetBySKUMock.callArgs, &mm_params)
	mmStocksServiceGetBySKU.StocksServiceGetBySKUMock.mutex.Unlock()

	for _, e := range mmStocksServiceGetBySKU.StocksServiceGetBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmStocksServiceGetBySKU.StocksServiceGetBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocksServiceGetBySKU.StocksServiceGetBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmStocksServiceGetBySKU.StocksServiceGetBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmStocksServiceGetBySKU.StocksServiceGetBySKUMock.defaultExpectation.paramPtrs

		mm_got := StocksServiceMockStocksServiceGetBySKUParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStocksServiceGetBySKU.t.Errorf("StocksServiceMock.StocksServiceGetBySKU got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmStocksServiceGetBySKU.t.Errorf("StocksServiceMock.StocksServiceGetBySKU got unexpected parameter sku, want: %#v, got: %#v%s\n", *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocksServiceGetBySKU.t.Errorf("StocksServiceMock.StocksServiceGetBySKU got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocksServiceGetBySKU.StocksServiceGetBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmStocksServiceGetBySKU.t.Fatal("No results are set for the StocksServiceMock.StocksServiceGetBySKU")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmStocksServiceGetBySKU.funcStocksServiceGetBySKU != nil {
		return mmStocksServiceGetBySKU.funcStocksServiceGetBySKU(ctx, sku)
	}
	mmStocksServiceGetBySKU.t.Fatalf("Unexpected call to StocksServiceMock.StocksServiceGetBySKU. %v %v", ctx, sku)
	return
}

// StocksServiceGetBySKUAfterCounter returns a count of finished StocksServiceMock.StocksServiceGetBySKU invocations
func (mmStocksServiceGetBySKU *StocksServiceMock) StocksServiceGetBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksServiceGetBySKU.afterStocksServiceGetBySKUCounter)
}

// StocksServiceGetBySKUBeforeCounter returns a count of StocksServiceMock.StocksServiceGetBySKU invocations
func (mmStocksServiceGetBySKU *StocksServiceMock) StocksServiceGetBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksServiceGetBySKU.beforeStocksServiceGetBySKUCounter)
}

// Calls returns a list of arguments used in each call to StocksServiceMock.StocksServiceGetBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocksServiceGetBySKU *mStocksServiceMockStocksServiceGetBySKU) Calls() []*StocksServiceMockStocksServiceGetBySKUParams {
	mmStocksServiceGetBySKU.mutex.RLock()

	argCopy := make([]*StocksServiceMockStocksServiceGetBySKUParams, len(mmStocksServiceGetBySKU.callArgs))
	copy(argCopy, mmStocksServiceGetBySKU.callArgs)

	mmStocksServiceGetBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockStocksServiceGetBySKUDone returns true if the count of the StocksServiceGetBySKU invocations corresponds
// the number of defined expectations
func (m *StocksServiceMock) MinimockStocksServiceGetBySKUDone() bool {
	if m.StocksServiceGetBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StocksServiceGetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StocksServiceGetBySKUMock.invocationsDone()
}

// MinimockStocksServiceGetBySKUInspect logs each unmet expectation
func (m *StocksServiceMock) MinimockStocksServiceGetBySKUInspect() {
	for _, e := range m.StocksServiceGetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksServiceMock.StocksServiceGetBySKU with params: %#v", *e.params)
		}
	}

	afterStocksServiceGetBySKUCounter := mm_atomic.LoadUint64(&m.afterStocksServiceGetBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StocksServiceGetBySKUMock.defaultExpectation != nil && afterStocksServiceGetBySKUCounter < 1 {
		if m.StocksServiceGetBySKUMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StocksServiceMock.StocksServiceGetBySKU")
		} else {
			m.t.Errorf("Expected call to StocksServiceMock.StocksServiceGetBySKU with params: %#v", *m.StocksServiceGetBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocksServiceGetBySKU != nil && afterStocksServiceGetBySKUCounter < 1 {
		m.t.Error("Expected call to StocksServiceMock.StocksServiceGetBySKU")
	}

	if !m.StocksServiceGetBySKUMock.invocationsDone() && afterStocksServiceGetBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksServiceMock.StocksServiceGetBySKU but found %d calls",
			mm_atomic.LoadUint64(&m.StocksServiceGetBySKUMock.expectedInvocations), afterStocksServiceGetBySKUCounter)
	}
}

type mStocksServiceMockStocksServiceReserve struct {
	optional           bool
	mock               *StocksServiceMock
	defaultExpectation *StocksServiceMockStocksServiceReserveExpectation
	expectations       []*StocksServiceMockStocksServiceReserveExpectation

	callArgs []*StocksServiceMockStocksServiceReserveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StocksServiceMockStocksServiceReserveExpectation specifies expectation struct of the StocksService.StocksServiceReserve
type StocksServiceMockStocksServiceReserveExpectation struct {
	mock      *StocksServiceMock
	params    *StocksServiceMockStocksServiceReserveParams
	paramPtrs *StocksServiceMockStocksServiceReserveParamPtrs
	results   *StocksServiceMockStocksServiceReserveResults
	Counter   uint64
}

// StocksServiceMockStocksServiceReserveParams contains parameters of the StocksService.StocksServiceReserve
type StocksServiceMockStocksServiceReserveParams struct {
	ctx   context.Context
	sku   stocksModel.SKU
	count int64
}

// StocksServiceMockStocksServiceReserveParamPtrs contains pointers to parameters of the StocksService.StocksServiceReserve
type StocksServiceMockStocksServiceReserveParamPtrs struct {
	ctx   *context.Context
	sku   *stocksModel.SKU
	count *int64
}

// StocksServiceMockStocksServiceReserveResults contains results of the StocksService.StocksServiceReserve
type StocksServiceMockStocksServiceReserveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) Optional() *mStocksServiceMockStocksServiceReserve {
	mmStocksServiceReserve.optional = true
	return mmStocksServiceReserve
}

// Expect sets up expected params for StocksService.StocksServiceReserve
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) Expect(ctx context.Context, sku stocksModel.SKU, count int64) *mStocksServiceMockStocksServiceReserve {
	if mmStocksServiceReserve.mock.funcStocksServiceReserve != nil {
		mmStocksServiceReserve.mock.t.Fatalf("StocksServiceMock.StocksServiceReserve mock is already set by Set")
	}

	if mmStocksServiceReserve.defaultExpectation == nil {
		mmStocksServiceReserve.defaultExpectation = &StocksServiceMockStocksServiceReserveExpectation{}
	}

	if mmStocksServiceReserve.defaultExpectation.paramPtrs != nil {
		mmStocksServiceReserve.mock.t.Fatalf("StocksServiceMock.StocksServiceReserve mock is already set by ExpectParams functions")
	}

	mmStocksServiceReserve.defaultExpectation.params = &StocksServiceMockStocksServiceReserveParams{ctx, sku, count}
	for _, e := range mmStocksServiceReserve.expectations {
		if minimock.Equal(e.params, mmStocksServiceReserve.defaultExpectation.params) {
			mmStocksServiceReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocksServiceReserve.defaultExpectation.params)
		}
	}

	return mmStocksServiceReserve
}

// ExpectCtxParam1 sets up expected param ctx for StocksService.StocksServiceReserve
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) ExpectCtxParam1(ctx context.Context) *mStocksServiceMockStocksServiceReserve {
	if mmStocksServiceReserve.mock.funcStocksServiceReserve != nil {
		mmStocksServiceReserve.mock.t.Fatalf("StocksServiceMock.StocksServiceReserve mock is already set by Set")
	}

	if mmStocksServiceReserve.defaultExpectation == nil {
		mmStocksServiceReserve.defaultExpectation = &StocksServiceMockStocksServiceReserveExpectation{}
	}

	if mmStocksServiceReserve.defaultExpectation.params != nil {
		mmStocksServiceReserve.mock.t.Fatalf("StocksServiceMock.StocksServiceReserve mock is already set by Expect")
	}

	if mmStocksServiceReserve.defaultExpectation.paramPtrs == nil {
		mmStocksServiceReserve.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceReserveParamPtrs{}
	}
	mmStocksServiceReserve.defaultExpectation.paramPtrs.ctx = &ctx

	return mmStocksServiceReserve
}

// ExpectSkuParam2 sets up expected param sku for StocksService.StocksServiceReserve
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) ExpectSkuParam2(sku stocksModel.SKU) *mStocksServiceMockStocksServiceReserve {
	if mmStocksServiceReserve.mock.funcStocksServiceReserve != nil {
		mmStocksServiceReserve.mock.t.Fatalf("StocksServiceMock.StocksServiceReserve mock is already set by Set")
	}

	if mmStocksServiceReserve.defaultExpectation == nil {
		mmStocksServiceReserve.defaultExpectation = &StocksServiceMockStocksServiceReserveExpectation{}
	}

	if mmStocksServiceReserve.defaultExpectation.params != nil {
		mmStocksServiceReserve.mock.t.Fatalf("StocksServiceMock.StocksServiceReserve mock is already set by Expect")
	}

	if mmStocksServiceReserve.defaultExpectation.paramPtrs == nil {
		mmStocksServiceReserve.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceReserveParamPtrs{}
	}
	mmStocksServiceReserve.defaultExpectation.paramPtrs.sku = &sku

	return mmStocksServiceReserve
}

// ExpectCountParam3 sets up expected param count for StocksService.StocksServiceReserve
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) ExpectCountParam3(count int64) *mStocksServiceMockStocksServiceReserve {
	if mmStocksServiceReserve.mock.funcStocksServiceReserve != nil {
		mmStocksServiceReserve.mock.t.Fatalf("StocksServiceMock.StocksServiceReserve mock is already set by Set")
	}

	if mmStocksServiceReserve.defaultExpectation == nil {
		mmStocksServiceReserve.defaultExpectation = &StocksServiceMockStocksServiceReserveExpectation{}
	}

	if mmStocksServiceReserve.defaultExpectation.params != nil {
		mmStocksServiceReserve.mock.t.Fatalf("StocksServiceMock.StocksServiceReserve mock is already set by Expect")
	}

	if mmStocksServiceReserve.defaultExpectation.paramPtrs == nil {
		mmStocksServiceReserve.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceReserveParamPtrs{}
	}
	mmStocksServiceReserve.defaultExpectation.paramPtrs.count = &count

	return mmStocksServiceReserve
}

// Inspect accepts an inspector function that has same arguments as the StocksService.StocksServiceReserve
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) Inspect(f func(ctx context.Context, sku stocksModel.SKU, count int64)) *mStocksServiceMockStocksServiceReserve {
	if mmStocksServiceReserve.mock.inspectFuncStocksServiceReserve != nil {
		mmStocksServiceReserve.mock.t.Fatalf("Inspect function is already set for StocksServiceMock.StocksServiceReserve")
	}

	mmStocksServiceReserve.mock.inspectFuncStocksServiceReserve = f

	return mmStocksServiceReserve
}

// Return sets up results that will be returned by StocksService.StocksServiceReserve
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) Return(err error) *StocksServiceMock {
	if mmStocksServiceReserve.mock.funcStocksServiceReserve != nil {
		mmStocksServiceReserve.mock.t.Fatalf("StocksServiceMock.StocksServiceReserve mock is already set by Set")
	}

	if mmStocksServiceReserve.defaultExpectation == nil {
		mmStocksServiceReserve.defaultExpectation = &StocksServiceMockStocksServiceReserveExpectation{mock: mmStocksServiceReserve.mock}
	}
	mmStocksServiceReserve.defaultExpectation.results = &StocksServiceMockStocksServiceReserveResults{err}
	return mmStocksServiceReserve.mock
}

// Set uses given function f to mock the StocksService.StocksServiceReserve method
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) Set(f func(ctx context.Context, sku stocksModel.SKU, count int64) (err error)) *StocksServiceMock {
	if mmStocksServiceReserve.defaultExpectation != nil {
		mmStocksServiceReserve.mock.t.Fatalf("Default expectation is already set for the StocksService.StocksServiceReserve method")
	}

	if len(mmStocksServiceReserve.expectations) > 0 {
		mmStocksServiceReserve.mock.t.Fatalf("Some expectations are already set for the StocksService.StocksServiceReserve method")
	}

	mmStocksServiceReserve.mock.funcStocksServiceReserve = f
	return mmStocksServiceReserve.mock
}

// When sets expectation for the StocksService.StocksServiceReserve which will trigger the result defined by the following
// Then helper
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) When(ctx context.Context, sku stocksModel.SKU, count int64) *StocksServiceMockStocksServiceReserveExpectation {
	if mmStocksServiceReserve.mock.funcStocksServiceReserve != nil {
		mmStocksServiceReserve.mock.t.Fatalf("StocksServiceMock.StocksServiceReserve mock is already set by Set")
	}

	expectation := &StocksServiceMockStocksServiceReserveExpectation{
		mock:   mmStocksServiceReserve.mock,
		params: &StocksServiceMockStocksServiceReserveParams{ctx, sku, count},
	}
	mmStocksServiceReserve.expectations = append(mmStocksServiceReserve.expectations, expectation)
	return expectation
}

// Then sets up StocksService.StocksServiceReserve return parameters for the expectation previously defined by the When method
func (e *StocksServiceMockStocksServiceReserveExpectation) Then(err error) *StocksServiceMock {
	e.results = &StocksServiceMockStocksServiceReserveResults{err}
	return e.mock
}

// Times sets number of times StocksService.StocksServiceReserve should be invoked
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) Times(n uint64) *mStocksServiceMockStocksServiceReserve {
	if n == 0 {
		mmStocksServiceReserve.mock.t.Fatalf("Times of StocksServiceMock.StocksServiceReserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStocksServiceReserve.expectedInvocations, n)
	return mmStocksServiceReserve
}

func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) invocationsDone() bool {
	if len(mmStocksServiceReserve.expectations) == 0 && mmStocksServiceReserve.defaultExpectation == nil && mmStocksServiceReserve.mock.funcStocksServiceReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStocksServiceReserve.mock.afterStocksServiceReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStocksServiceReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StocksServiceReserve implements handler.StocksService
func (mmStocksServiceReserve *StocksServiceMock) StocksServiceReserve(ctx context.Context, sku stocksModel.SKU, count int64) (err error) {
	mm_atomic.AddUint64(&mmStocksServiceReserve.beforeStocksServiceReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmStocksServiceReserve.afterStocksServiceReserveCounter, 1)

	if mmStocksServiceReserve.inspectFuncStocksServiceReserve != nil {
		mmStocksServiceReserve.inspectFuncStocksServiceReserve(ctx, sku, count)
	}

	mm_params := StocksServiceMockStocksServiceReserveParams{ctx, sku, count}

	// Record call args
	mmStocksServiceReserve.StocksServiceReserveMock.mutex.Lock()
	mmStocksServiceReserve.StocksServiceReserveMock.callArgs = append(mmStocksServiceReserve.StocksServiceReserveMock.callArgs, &mm_params)
	mmStocksServiceReserve.StocksServiceReserveMock.mutex.Unlock()

	for _, e := range mmStocksServiceReserve.StocksServiceReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStocksServiceReserve.StocksServiceReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocksServiceReserve.StocksServiceReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmStocksServiceReserve.StocksServiceReserveMock.defaultExpectation.params
		mm_want_ptrs := mmStocksServiceReserve.StocksServiceReserveMock.defaultExpectation.paramPtrs

		mm_got := StocksServiceMockStocksServiceReserveParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStocksServiceReserve.t.Errorf("StocksServiceMock.StocksServiceReserve got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmStocksServiceReserve.t.Errorf("StocksServiceMock.StocksServiceReserve got unexpected parameter sku, want: %#v, got: %#v%s\n", *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmStocksServiceReserve.t.Errorf("StocksServiceMock.StocksServiceReserve got unexpected parameter count, want: %#v, got: %#v%s\n", *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocksServiceReserve.t.Errorf("StocksServiceMock.StocksServiceReserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocksServiceReserve.StocksServiceReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmStocksServiceReserve.t.Fatal("No results are set for the StocksServiceMock.StocksServiceReserve")
		}
		return (*mm_results).err
	}
	if mmStocksServiceReserve.funcStocksServiceReserve != nil {
		return mmStocksServiceReserve.funcStocksServiceReserve(ctx, sku, count)
	}
	mmStocksServiceReserve.t.Fatalf("Unexpected call to StocksServiceMock.StocksServiceReserve. %v %v %v", ctx, sku, count)
	return
}

// StocksServiceReserveAfterCounter returns a count of finished StocksServiceMock.StocksServiceReserve invocations
func (mmStocksServiceReserve *StocksServiceMock) StocksServiceReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksServiceReserve.afterStocksServiceReserveCounter)
}

// StocksServiceReserveBeforeCounter returns a count of StocksServiceMock.StocksServiceReserve invocations
func (mmStocksServiceReserve *StocksServiceMock) StocksServiceReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksServiceReserve.beforeStocksServiceReserveCounter)
}

// Calls returns a list of arguments used in each call to StocksServiceMock.StocksServiceReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocksServiceReserve *mStocksServiceMockStocksServiceReserve) Calls() []*StocksServiceMockStocksServiceReserveParams {
	mmStocksServiceReserve.mutex.RLock()

	argCopy := make([]*StocksServiceMockStocksServiceReserveParams, len(mmStocksServiceReserve.callArgs))
	copy(argCopy, mmStocksServiceReserve.callArgs)

	mmStocksServiceReserve.mutex.RUnlock()

	return argCopy
}

// MinimockStocksServiceReserveDone returns true if the count of the StocksServiceReserve invocations corresponds
// the number of defined expectations
func (m *StocksServiceMock) MinimockStocksServiceReserveDone() bool {
	if m.StocksServiceReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StocksServiceReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StocksServiceReserveMock.invocationsDone()
}

// MinimockStocksServiceReserveInspect logs each unmet expectation
func (m *StocksServiceMock) MinimockStocksServiceReserveInspect() {
	for _, e := range m.StocksServiceReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksServiceMock.StocksServiceReserve with params: %#v", *e.params)
		}
	}

	afterStocksServiceReserveCounter := mm_atomic.LoadUint64(&m.afterStocksServiceReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StocksServiceReserveMock.defaultExpectation != nil && afterStocksServiceReserveCounter < 1 {
		if m.StocksServiceReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StocksServiceMock.StocksServiceReserve")
		} else {
			m.t.Errorf("Expected call to StocksServiceMock.StocksServiceReserve with params: %#v", *m.StocksServiceReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocksServiceReserve != nil && afterStocksServiceReserveCounter < 1 {
		m.t.Error("Expected call to StocksServiceMock.StocksServiceReserve")
	}

	if !m.StocksServiceReserveMock.invocationsDone() && afterStocksServiceReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksServiceMock.StocksServiceReserve but found %d calls",
			mm_atomic.LoadUint64(&m.StocksServiceReserveMock.expectedInvocations), afterStocksServiceReserveCounter)
	}
}

type mStocksServiceMockStocksServiceReserveCancel struct {
	optional           bool
	mock               *StocksServiceMock
	defaultExpectation *StocksServiceMockStocksServiceReserveCancelExpectation
	expectations       []*StocksServiceMockStocksServiceReserveCancelExpectation

	callArgs []*StocksServiceMockStocksServiceReserveCancelParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StocksServiceMockStocksServiceReserveCancelExpectation specifies expectation struct of the StocksService.StocksServiceReserveCancel
type StocksServiceMockStocksServiceReserveCancelExpectation struct {
	mock      *StocksServiceMock
	params    *StocksServiceMockStocksServiceReserveCancelParams
	paramPtrs *StocksServiceMockStocksServiceReserveCancelParamPtrs
	results   *StocksServiceMockStocksServiceReserveCancelResults
	Counter   uint64
}

// StocksServiceMockStocksServiceReserveCancelParams contains parameters of the StocksService.StocksServiceReserveCancel
type StocksServiceMockStocksServiceReserveCancelParams struct {
	ctx   context.Context
	sku   stocksModel.SKU
	count int64
}

// StocksServiceMockStocksServiceReserveCancelParamPtrs contains pointers to parameters of the StocksService.StocksServiceReserveCancel
type StocksServiceMockStocksServiceReserveCancelParamPtrs struct {
	ctx   *context.Context
	sku   *stocksModel.SKU
	count *int64
}

// StocksServiceMockStocksServiceReserveCancelResults contains results of the StocksService.StocksServiceReserveCancel
type StocksServiceMockStocksServiceReserveCancelResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) Optional() *mStocksServiceMockStocksServiceReserveCancel {
	mmStocksServiceReserveCancel.optional = true
	return mmStocksServiceReserveCancel
}

// Expect sets up expected params for StocksService.StocksServiceReserveCancel
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) Expect(ctx context.Context, sku stocksModel.SKU, count int64) *mStocksServiceMockStocksServiceReserveCancel {
	if mmStocksServiceReserveCancel.mock.funcStocksServiceReserveCancel != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveCancel mock is already set by Set")
	}

	if mmStocksServiceReserveCancel.defaultExpectation == nil {
		mmStocksServiceReserveCancel.defaultExpectation = &StocksServiceMockStocksServiceReserveCancelExpectation{}
	}

	if mmStocksServiceReserveCancel.defaultExpectation.paramPtrs != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveCancel mock is already set by ExpectParams functions")
	}

	mmStocksServiceReserveCancel.defaultExpectation.params = &StocksServiceMockStocksServiceReserveCancelParams{ctx, sku, count}
	for _, e := range mmStocksServiceReserveCancel.expectations {
		if minimock.Equal(e.params, mmStocksServiceReserveCancel.defaultExpectation.params) {
			mmStocksServiceReserveCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocksServiceReserveCancel.defaultExpectation.params)
		}
	}

	return mmStocksServiceReserveCancel
}

// ExpectCtxParam1 sets up expected param ctx for StocksService.StocksServiceReserveCancel
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) ExpectCtxParam1(ctx context.Context) *mStocksServiceMockStocksServiceReserveCancel {
	if mmStocksServiceReserveCancel.mock.funcStocksServiceReserveCancel != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveCancel mock is already set by Set")
	}

	if mmStocksServiceReserveCancel.defaultExpectation == nil {
		mmStocksServiceReserveCancel.defaultExpectation = &StocksServiceMockStocksServiceReserveCancelExpectation{}
	}

	if mmStocksServiceReserveCancel.defaultExpectation.params != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveCancel mock is already set by Expect")
	}

	if mmStocksServiceReserveCancel.defaultExpectation.paramPtrs == nil {
		mmStocksServiceReserveCancel.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceReserveCancelParamPtrs{}
	}
	mmStocksServiceReserveCancel.defaultExpectation.paramPtrs.ctx = &ctx

	return mmStocksServiceReserveCancel
}

// ExpectSkuParam2 sets up expected param sku for StocksService.StocksServiceReserveCancel
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) ExpectSkuParam2(sku stocksModel.SKU) *mStocksServiceMockStocksServiceReserveCancel {
	if mmStocksServiceReserveCancel.mock.funcStocksServiceReserveCancel != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveCancel mock is already set by Set")
	}

	if mmStocksServiceReserveCancel.defaultExpectation == nil {
		mmStocksServiceReserveCancel.defaultExpectation = &StocksServiceMockStocksServiceReserveCancelExpectation{}
	}

	if mmStocksServiceReserveCancel.defaultExpectation.params != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveCancel mock is already set by Expect")
	}

	if mmStocksServiceReserveCancel.defaultExpectation.paramPtrs == nil {
		mmStocksServiceReserveCancel.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceReserveCancelParamPtrs{}
	}
	mmStocksServiceReserveCancel.defaultExpectation.paramPtrs.sku = &sku

	return mmStocksServiceReserveCancel
}

// ExpectCountParam3 sets up expected param count for StocksService.StocksServiceReserveCancel
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) ExpectCountParam3(count int64) *mStocksServiceMockStocksServiceReserveCancel {
	if mmStocksServiceReserveCancel.mock.funcStocksServiceReserveCancel != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveCancel mock is already set by Set")
	}

	if mmStocksServiceReserveCancel.defaultExpectation == nil {
		mmStocksServiceReserveCancel.defaultExpectation = &StocksServiceMockStocksServiceReserveCancelExpectation{}
	}

	if mmStocksServiceReserveCancel.defaultExpectation.params != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveCancel mock is already set by Expect")
	}

	if mmStocksServiceReserveCancel.defaultExpectation.paramPtrs == nil {
		mmStocksServiceReserveCancel.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceReserveCancelParamPtrs{}
	}
	mmStocksServiceReserveCancel.defaultExpectation.paramPtrs.count = &count

	return mmStocksServiceReserveCancel
}

// Inspect accepts an inspector function that has same arguments as the StocksService.StocksServiceReserveCancel
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) Inspect(f func(ctx context.Context, sku stocksModel.SKU, count int64)) *mStocksServiceMockStocksServiceReserveCancel {
	if mmStocksServiceReserveCancel.mock.inspectFuncStocksServiceReserveCancel != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("Inspect function is already set for StocksServiceMock.StocksServiceReserveCancel")
	}

	mmStocksServiceReserveCancel.mock.inspectFuncStocksServiceReserveCancel = f

	return mmStocksServiceReserveCancel
}

// Return sets up results that will be returned by StocksService.StocksServiceReserveCancel
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) Return(err error) *StocksServiceMock {
	if mmStocksServiceReserveCancel.mock.funcStocksServiceReserveCancel != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveCancel mock is already set by Set")
	}

	if mmStocksServiceReserveCancel.defaultExpectation == nil {
		mmStocksServiceReserveCancel.defaultExpectation = &StocksServiceMockStocksServiceReserveCancelExpectation{mock: mmStocksServiceReserveCancel.mock}
	}
	mmStocksServiceReserveCancel.defaultExpectation.results = &StocksServiceMockStocksServiceReserveCancelResults{err}
	return mmStocksServiceReserveCancel.mock
}

// Set uses given function f to mock the StocksService.StocksServiceReserveCancel method
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) Set(f func(ctx context.Context, sku stocksModel.SKU, count int64) (err error)) *StocksServiceMock {
	if mmStocksServiceReserveCancel.defaultExpectation != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("Default expectation is already set for the StocksService.StocksServiceReserveCancel method")
	}

	if len(mmStocksServiceReserveCancel.expectations) > 0 {
		mmStocksServiceReserveCancel.mock.t.Fatalf("Some expectations are already set for the StocksService.StocksServiceReserveCancel method")
	}

	mmStocksServiceReserveCancel.mock.funcStocksServiceReserveCancel = f
	return mmStocksServiceReserveCancel.mock
}

// When sets expectation for the StocksService.StocksServiceReserveCancel which will trigger the result defined by the following
// Then helper
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) When(ctx context.Context, sku stocksModel.SKU, count int64) *StocksServiceMockStocksServiceReserveCancelExpectation {
	if mmStocksServiceReserveCancel.mock.funcStocksServiceReserveCancel != nil {
		mmStocksServiceReserveCancel.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveCancel mock is already set by Set")
	}

	expectation := &StocksServiceMockStocksServiceReserveCancelExpectation{
		mock:   mmStocksServiceReserveCancel.mock,
		params: &StocksServiceMockStocksServiceReserveCancelParams{ctx, sku, count},
	}
	mmStocksServiceReserveCancel.expectations = append(mmStocksServiceReserveCancel.expectations, expectation)
	return expectation
}

// Then sets up StocksService.StocksServiceReserveCancel return parameters for the expectation previously defined by the When method
func (e *StocksServiceMockStocksServiceReserveCancelExpectation) Then(err error) *StocksServiceMock {
	e.results = &StocksServiceMockStocksServiceReserveCancelResults{err}
	return e.mock
}

// Times sets number of times StocksService.StocksServiceReserveCancel should be invoked
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) Times(n uint64) *mStocksServiceMockStocksServiceReserveCancel {
	if n == 0 {
		mmStocksServiceReserveCancel.mock.t.Fatalf("Times of StocksServiceMock.StocksServiceReserveCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStocksServiceReserveCancel.expectedInvocations, n)
	return mmStocksServiceReserveCancel
}

func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) invocationsDone() bool {
	if len(mmStocksServiceReserveCancel.expectations) == 0 && mmStocksServiceReserveCancel.defaultExpectation == nil && mmStocksServiceReserveCancel.mock.funcStocksServiceReserveCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStocksServiceReserveCancel.mock.afterStocksServiceReserveCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStocksServiceReserveCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StocksServiceReserveCancel implements handler.StocksService
func (mmStocksServiceReserveCancel *StocksServiceMock) StocksServiceReserveCancel(ctx context.Context, sku stocksModel.SKU, count int64) (err error) {
	mm_atomic.AddUint64(&mmStocksServiceReserveCancel.beforeStocksServiceReserveCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmStocksServiceReserveCancel.afterStocksServiceReserveCancelCounter, 1)

	if mmStocksServiceReserveCancel.inspectFuncStocksServiceReserveCancel != nil {
		mmStocksServiceReserveCancel.inspectFuncStocksServiceReserveCancel(ctx, sku, count)
	}

	mm_params := StocksServiceMockStocksServiceReserveCancelParams{ctx, sku, count}

	// Record call args
	mmStocksServiceReserveCancel.StocksServiceReserveCancelMock.mutex.Lock()
	mmStocksServiceReserveCancel.StocksServiceReserveCancelMock.callArgs = append(mmStocksServiceReserveCancel.StocksServiceReserveCancelMock.callArgs, &mm_params)
	mmStocksServiceReserveCancel.StocksServiceReserveCancelMock.mutex.Unlock()

	for _, e := range mmStocksServiceReserveCancel.StocksServiceReserveCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStocksServiceReserveCancel.StocksServiceReserveCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocksServiceReserveCancel.StocksServiceReserveCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmStocksServiceReserveCancel.StocksServiceReserveCancelMock.defaultExpectation.params
		mm_want_ptrs := mmStocksServiceReserveCancel.StocksServiceReserveCancelMock.defaultExpectation.paramPtrs

		mm_got := StocksServiceMockStocksServiceReserveCancelParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStocksServiceReserveCancel.t.Errorf("StocksServiceMock.StocksServiceReserveCancel got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmStocksServiceReserveCancel.t.Errorf("StocksServiceMock.StocksServiceReserveCancel got unexpected parameter sku, want: %#v, got: %#v%s\n", *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmStocksServiceReserveCancel.t.Errorf("StocksServiceMock.StocksServiceReserveCancel got unexpected parameter count, want: %#v, got: %#v%s\n", *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocksServiceReserveCancel.t.Errorf("StocksServiceMock.StocksServiceReserveCancel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocksServiceReserveCancel.StocksServiceReserveCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmStocksServiceReserveCancel.t.Fatal("No results are set for the StocksServiceMock.StocksServiceReserveCancel")
		}
		return (*mm_results).err
	}
	if mmStocksServiceReserveCancel.funcStocksServiceReserveCancel != nil {
		return mmStocksServiceReserveCancel.funcStocksServiceReserveCancel(ctx, sku, count)
	}
	mmStocksServiceReserveCancel.t.Fatalf("Unexpected call to StocksServiceMock.StocksServiceReserveCancel. %v %v %v", ctx, sku, count)
	return
}

// StocksServiceReserveCancelAfterCounter returns a count of finished StocksServiceMock.StocksServiceReserveCancel invocations
func (mmStocksServiceReserveCancel *StocksServiceMock) StocksServiceReserveCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksServiceReserveCancel.afterStocksServiceReserveCancelCounter)
}

// StocksServiceReserveCancelBeforeCounter returns a count of StocksServiceMock.StocksServiceReserveCancel invocations
func (mmStocksServiceReserveCancel *StocksServiceMock) StocksServiceReserveCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksServiceReserveCancel.beforeStocksServiceReserveCancelCounter)
}

// Calls returns a list of arguments used in each call to StocksServiceMock.StocksServiceReserveCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocksServiceReserveCancel *mStocksServiceMockStocksServiceReserveCancel) Calls() []*StocksServiceMockStocksServiceReserveCancelParams {
	mmStocksServiceReserveCancel.mutex.RLock()

	argCopy := make([]*StocksServiceMockStocksServiceReserveCancelParams, len(mmStocksServiceReserveCancel.callArgs))
	copy(argCopy, mmStocksServiceReserveCancel.callArgs)

	mmStocksServiceReserveCancel.mutex.RUnlock()

	return argCopy
}

// MinimockStocksServiceReserveCancelDone returns true if the count of the StocksServiceReserveCancel invocations corresponds
// the number of defined expectations
func (m *StocksServiceMock) MinimockStocksServiceReserveCancelDone() bool {
	if m.StocksServiceReserveCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StocksServiceReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StocksServiceReserveCancelMock.invocationsDone()
}

// MinimockStocksServiceReserveCancelInspect logs each unmet expectation
func (m *StocksServiceMock) MinimockStocksServiceReserveCancelInspect() {
	for _, e := range m.StocksServiceReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksServiceMock.StocksServiceReserveCancel with params: %#v", *e.params)
		}
	}

	afterStocksServiceReserveCancelCounter := mm_atomic.LoadUint64(&m.afterStocksServiceReserveCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StocksServiceReserveCancelMock.defaultExpectation != nil && afterStocksServiceReserveCancelCounter < 1 {
		if m.StocksServiceReserveCancelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StocksServiceMock.StocksServiceReserveCancel")
		} else {
			m.t.Errorf("Expected call to StocksServiceMock.StocksServiceReserveCancel with params: %#v", *m.StocksServiceReserveCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocksServiceReserveCancel != nil && afterStocksServiceReserveCancelCounter < 1 {
		m.t.Error("Expected call to StocksServiceMock.StocksServiceReserveCancel")
	}

	if !m.StocksServiceReserveCancelMock.invocationsDone() && afterStocksServiceReserveCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksServiceMock.StocksServiceReserveCancel but found %d calls",
			mm_atomic.LoadUint64(&m.StocksServiceReserveCancelMock.expectedInvocations), afterStocksServiceReserveCancelCounter)
	}
}

type mStocksServiceMockStocksServiceReserveRemove struct {
	optional           bool
	mock               *StocksServiceMock
	defaultExpectation *StocksServiceMockStocksServiceReserveRemoveExpectation
	expectations       []*StocksServiceMockStocksServiceReserveRemoveExpectation

	callArgs []*StocksServiceMockStocksServiceReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StocksServiceMockStocksServiceReserveRemoveExpectation specifies expectation struct of the StocksService.StocksServiceReserveRemove
type StocksServiceMockStocksServiceReserveRemoveExpectation struct {
	mock      *StocksServiceMock
	params    *StocksServiceMockStocksServiceReserveRemoveParams
	paramPtrs *StocksServiceMockStocksServiceReserveRemoveParamPtrs
	results   *StocksServiceMockStocksServiceReserveRemoveResults
	Counter   uint64
}

// StocksServiceMockStocksServiceReserveRemoveParams contains parameters of the StocksService.StocksServiceReserveRemove
type StocksServiceMockStocksServiceReserveRemoveParams struct {
	ctx   context.Context
	sku   stocksModel.SKU
	count int64
}

// StocksServiceMockStocksServiceReserveRemoveParamPtrs contains pointers to parameters of the StocksService.StocksServiceReserveRemove
type StocksServiceMockStocksServiceReserveRemoveParamPtrs struct {
	ctx   *context.Context
	sku   *stocksModel.SKU
	count *int64
}

// StocksServiceMockStocksServiceReserveRemoveResults contains results of the StocksService.StocksServiceReserveRemove
type StocksServiceMockStocksServiceReserveRemoveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) Optional() *mStocksServiceMockStocksServiceReserveRemove {
	mmStocksServiceReserveRemove.optional = true
	return mmStocksServiceReserveRemove
}

// Expect sets up expected params for StocksService.StocksServiceReserveRemove
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) Expect(ctx context.Context, sku stocksModel.SKU, count int64) *mStocksServiceMockStocksServiceReserveRemove {
	if mmStocksServiceReserveRemove.mock.funcStocksServiceReserveRemove != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveRemove mock is already set by Set")
	}

	if mmStocksServiceReserveRemove.defaultExpectation == nil {
		mmStocksServiceReserveRemove.defaultExpectation = &StocksServiceMockStocksServiceReserveRemoveExpectation{}
	}

	if mmStocksServiceReserveRemove.defaultExpectation.paramPtrs != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveRemove mock is already set by ExpectParams functions")
	}

	mmStocksServiceReserveRemove.defaultExpectation.params = &StocksServiceMockStocksServiceReserveRemoveParams{ctx, sku, count}
	for _, e := range mmStocksServiceReserveRemove.expectations {
		if minimock.Equal(e.params, mmStocksServiceReserveRemove.defaultExpectation.params) {
			mmStocksServiceReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocksServiceReserveRemove.defaultExpectation.params)
		}
	}

	return mmStocksServiceReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for StocksService.StocksServiceReserveRemove
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) ExpectCtxParam1(ctx context.Context) *mStocksServiceMockStocksServiceReserveRemove {
	if mmStocksServiceReserveRemove.mock.funcStocksServiceReserveRemove != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveRemove mock is already set by Set")
	}

	if mmStocksServiceReserveRemove.defaultExpectation == nil {
		mmStocksServiceReserveRemove.defaultExpectation = &StocksServiceMockStocksServiceReserveRemoveExpectation{}
	}

	if mmStocksServiceReserveRemove.defaultExpectation.params != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveRemove mock is already set by Expect")
	}

	if mmStocksServiceReserveRemove.defaultExpectation.paramPtrs == nil {
		mmStocksServiceReserveRemove.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceReserveRemoveParamPtrs{}
	}
	mmStocksServiceReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx

	return mmStocksServiceReserveRemove
}

// ExpectSkuParam2 sets up expected param sku for StocksService.StocksServiceReserveRemove
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) ExpectSkuParam2(sku stocksModel.SKU) *mStocksServiceMockStocksServiceReserveRemove {
	if mmStocksServiceReserveRemove.mock.funcStocksServiceReserveRemove != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveRemove mock is already set by Set")
	}

	if mmStocksServiceReserveRemove.defaultExpectation == nil {
		mmStocksServiceReserveRemove.defaultExpectation = &StocksServiceMockStocksServiceReserveRemoveExpectation{}
	}

	if mmStocksServiceReserveRemove.defaultExpectation.params != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveRemove mock is already set by Expect")
	}

	if mmStocksServiceReserveRemove.defaultExpectation.paramPtrs == nil {
		mmStocksServiceReserveRemove.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceReserveRemoveParamPtrs{}
	}
	mmStocksServiceReserveRemove.defaultExpectation.paramPtrs.sku = &sku

	return mmStocksServiceReserveRemove
}

// ExpectCountParam3 sets up expected param count for StocksService.StocksServiceReserveRemove
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) ExpectCountParam3(count int64) *mStocksServiceMockStocksServiceReserveRemove {
	if mmStocksServiceReserveRemove.mock.funcStocksServiceReserveRemove != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveRemove mock is already set by Set")
	}

	if mmStocksServiceReserveRemove.defaultExpectation == nil {
		mmStocksServiceReserveRemove.defaultExpectation = &StocksServiceMockStocksServiceReserveRemoveExpectation{}
	}

	if mmStocksServiceReserveRemove.defaultExpectation.params != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveRemove mock is already set by Expect")
	}

	if mmStocksServiceReserveRemove.defaultExpectation.paramPtrs == nil {
		mmStocksServiceReserveRemove.defaultExpectation.paramPtrs = &StocksServiceMockStocksServiceReserveRemoveParamPtrs{}
	}
	mmStocksServiceReserveRemove.defaultExpectation.paramPtrs.count = &count

	return mmStocksServiceReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the StocksService.StocksServiceReserveRemove
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) Inspect(f func(ctx context.Context, sku stocksModel.SKU, count int64)) *mStocksServiceMockStocksServiceReserveRemove {
	if mmStocksServiceReserveRemove.mock.inspectFuncStocksServiceReserveRemove != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("Inspect function is already set for StocksServiceMock.StocksServiceReserveRemove")
	}

	mmStocksServiceReserveRemove.mock.inspectFuncStocksServiceReserveRemove = f

	return mmStocksServiceReserveRemove
}

// Return sets up results that will be returned by StocksService.StocksServiceReserveRemove
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) Return(err error) *StocksServiceMock {
	if mmStocksServiceReserveRemove.mock.funcStocksServiceReserveRemove != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveRemove mock is already set by Set")
	}

	if mmStocksServiceReserveRemove.defaultExpectation == nil {
		mmStocksServiceReserveRemove.defaultExpectation = &StocksServiceMockStocksServiceReserveRemoveExpectation{mock: mmStocksServiceReserveRemove.mock}
	}
	mmStocksServiceReserveRemove.defaultExpectation.results = &StocksServiceMockStocksServiceReserveRemoveResults{err}
	return mmStocksServiceReserveRemove.mock
}

// Set uses given function f to mock the StocksService.StocksServiceReserveRemove method
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) Set(f func(ctx context.Context, sku stocksModel.SKU, count int64) (err error)) *StocksServiceMock {
	if mmStocksServiceReserveRemove.defaultExpectation != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("Default expectation is already set for the StocksService.StocksServiceReserveRemove method")
	}

	if len(mmStocksServiceReserveRemove.expectations) > 0 {
		mmStocksServiceReserveRemove.mock.t.Fatalf("Some expectations are already set for the StocksService.StocksServiceReserveRemove method")
	}

	mmStocksServiceReserveRemove.mock.funcStocksServiceReserveRemove = f
	return mmStocksServiceReserveRemove.mock
}

// When sets expectation for the StocksService.StocksServiceReserveRemove which will trigger the result defined by the following
// Then helper
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) When(ctx context.Context, sku stocksModel.SKU, count int64) *StocksServiceMockStocksServiceReserveRemoveExpectation {
	if mmStocksServiceReserveRemove.mock.funcStocksServiceReserveRemove != nil {
		mmStocksServiceReserveRemove.mock.t.Fatalf("StocksServiceMock.StocksServiceReserveRemove mock is already set by Set")
	}

	expectation := &StocksServiceMockStocksServiceReserveRemoveExpectation{
		mock:   mmStocksServiceReserveRemove.mock,
		params: &StocksServiceMockStocksServiceReserveRemoveParams{ctx, sku, count},
	}
	mmStocksServiceReserveRemove.expectations = append(mmStocksServiceReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up StocksService.StocksServiceReserveRemove return parameters for the expectation previously defined by the When method
func (e *StocksServiceMockStocksServiceReserveRemoveExpectation) Then(err error) *StocksServiceMock {
	e.results = &StocksServiceMockStocksServiceReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times StocksService.StocksServiceReserveRemove should be invoked
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) Times(n uint64) *mStocksServiceMockStocksServiceReserveRemove {
	if n == 0 {
		mmStocksServiceReserveRemove.mock.t.Fatalf("Times of StocksServiceMock.StocksServiceReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStocksServiceReserveRemove.expectedInvocations, n)
	return mmStocksServiceReserveRemove
}

func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) invocationsDone() bool {
	if len(mmStocksServiceReserveRemove.expectations) == 0 && mmStocksServiceReserveRemove.defaultExpectation == nil && mmStocksServiceReserveRemove.mock.funcStocksServiceReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStocksServiceReserveRemove.mock.afterStocksServiceReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStocksServiceReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StocksServiceReserveRemove implements handler.StocksService
func (mmStocksServiceReserveRemove *StocksServiceMock) StocksServiceReserveRemove(ctx context.Context, sku stocksModel.SKU, count int64) (err error) {
	mm_atomic.AddUint64(&mmStocksServiceReserveRemove.beforeStocksServiceReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmStocksServiceReserveRemove.afterStocksServiceReserveRemoveCounter, 1)

	if mmStocksServiceReserveRemove.inspectFuncStocksServiceReserveRemove != nil {
		mmStocksServiceReserveRemove.inspectFuncStocksServiceReserveRemove(ctx, sku, count)
	}

	mm_params := StocksServiceMockStocksServiceReserveRemoveParams{ctx, sku, count}

	// Record call args
	mmStocksServiceReserveRemove.StocksServiceReserveRemoveMock.mutex.Lock()
	mmStocksServiceReserveRemove.StocksServiceReserveRemoveMock.callArgs = append(mmStocksServiceReserveRemove.StocksServiceReserveRemoveMock.callArgs, &mm_params)
	mmStocksServiceReserveRemove.StocksServiceReserveRemoveMock.mutex.Unlock()

	for _, e := range mmStocksServiceReserveRemove.StocksServiceReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStocksServiceReserveRemove.StocksServiceReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocksServiceReserveRemove.StocksServiceReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmStocksServiceReserveRemove.StocksServiceReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmStocksServiceReserveRemove.StocksServiceReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := StocksServiceMockStocksServiceReserveRemoveParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStocksServiceReserveRemove.t.Errorf("StocksServiceMock.StocksServiceReserveRemove got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmStocksServiceReserveRemove.t.Errorf("StocksServiceMock.StocksServiceReserveRemove got unexpected parameter sku, want: %#v, got: %#v%s\n", *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmStocksServiceReserveRemove.t.Errorf("StocksServiceMock.StocksServiceReserveRemove got unexpected parameter count, want: %#v, got: %#v%s\n", *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocksServiceReserveRemove.t.Errorf("StocksServiceMock.StocksServiceReserveRemove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocksServiceReserveRemove.StocksServiceReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmStocksServiceReserveRemove.t.Fatal("No results are set for the StocksServiceMock.StocksServiceReserveRemove")
		}
		return (*mm_results).err
	}
	if mmStocksServiceReserveRemove.funcStocksServiceReserveRemove != nil {
		return mmStocksServiceReserveRemove.funcStocksServiceReserveRemove(ctx, sku, count)
	}
	mmStocksServiceReserveRemove.t.Fatalf("Unexpected call to StocksServiceMock.StocksServiceReserveRemove. %v %v %v", ctx, sku, count)
	return
}

// StocksServiceReserveRemoveAfterCounter returns a count of finished StocksServiceMock.StocksServiceReserveRemove invocations
func (mmStocksServiceReserveRemove *StocksServiceMock) StocksServiceReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksServiceReserveRemove.afterStocksServiceReserveRemoveCounter)
}

// StocksServiceReserveRemoveBeforeCounter returns a count of StocksServiceMock.StocksServiceReserveRemove invocations
func (mmStocksServiceReserveRemove *StocksServiceMock) StocksServiceReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksServiceReserveRemove.beforeStocksServiceReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to StocksServiceMock.StocksServiceReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocksServiceReserveRemove *mStocksServiceMockStocksServiceReserveRemove) Calls() []*StocksServiceMockStocksServiceReserveRemoveParams {
	mmStocksServiceReserveRemove.mutex.RLock()

	argCopy := make([]*StocksServiceMockStocksServiceReserveRemoveParams, len(mmStocksServiceReserveRemove.callArgs))
	copy(argCopy, mmStocksServiceReserveRemove.callArgs)

	mmStocksServiceReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockStocksServiceReserveRemoveDone returns true if the count of the StocksServiceReserveRemove invocations corresponds
// the number of defined expectations
func (m *StocksServiceMock) MinimockStocksServiceReserveRemoveDone() bool {
	if m.StocksServiceReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StocksServiceReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StocksServiceReserveRemoveMock.invocationsDone()
}

// MinimockStocksServiceReserveRemoveInspect logs each unmet expectation
func (m *StocksServiceMock) MinimockStocksServiceReserveRemoveInspect() {
	for _, e := range m.StocksServiceReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksServiceMock.StocksServiceReserveRemove with params: %#v", *e.params)
		}
	}

	afterStocksServiceReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterStocksServiceReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StocksServiceReserveRemoveMock.defaultExpectation != nil && afterStocksServiceReserveRemoveCounter < 1 {
		if m.StocksServiceReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StocksServiceMock.StocksServiceReserveRemove")
		} else {
			m.t.Errorf("Expected call to StocksServiceMock.StocksServiceReserveRemove with params: %#v", *m.StocksServiceReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocksServiceReserveRemove != nil && afterStocksServiceReserveRemoveCounter < 1 {
		m.t.Error("Expected call to StocksServiceMock.StocksServiceReserveRemove")
	}

	if !m.StocksServiceReserveRemoveMock.invocationsDone() && afterStocksServiceReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksServiceMock.StocksServiceReserveRemove but found %d calls",
			mm_atomic.LoadUint64(&m.StocksServiceReserveRemoveMock.expectedInvocations), afterStocksServiceReserveRemoveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StocksServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockStocksServiceGetBySKUInspect()

			m.MinimockStocksServiceReserveInspect()

			m.MinimockStocksServiceReserveCancelInspect()

			m.MinimockStocksServiceReserveRemoveInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StocksServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StocksServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockStocksServiceGetBySKUDone() &&
		m.MinimockStocksServiceReserveDone() &&
		m.MinimockStocksServiceReserveCancelDone() &&
		m.MinimockStocksServiceReserveRemoveDone()
}
