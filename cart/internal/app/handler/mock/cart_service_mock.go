// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

//go:generate minimock -i route256/cart/internal/app/handler.CartService -o cart_service_mock.go -n CartServiceMock -p mock

import (
	"route256/cart/internal/cart/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartServiceMock implements handler.CartService
type CartServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItemsToCart          func(userID model.UserID, item model.Item)
	inspectFuncAddItemsToCart   func(userID model.UserID, item model.Item)
	afterAddItemsToCartCounter  uint64
	beforeAddItemsToCartCounter uint64
	AddItemsToCartMock          mCartServiceMockAddItemsToCart

	funcDeleteCartByUserID          func(userID model.UserID)
	inspectFuncDeleteCartByUserID   func(userID model.UserID)
	afterDeleteCartByUserIDCounter  uint64
	beforeDeleteCartByUserIDCounter uint64
	DeleteCartByUserIDMock          mCartServiceMockDeleteCartByUserID

	funcDeleteItemsFromCart          func(userID model.UserID, itemID model.SkuID)
	inspectFuncDeleteItemsFromCart   func(userID model.UserID, itemID model.SkuID)
	afterDeleteItemsFromCartCounter  uint64
	beforeDeleteItemsFromCartCounter uint64
	DeleteItemsFromCartMock          mCartServiceMockDeleteItemsFromCart

	funcGetCartByUserID          func(userID model.UserID) (cp1 *model.Cart, err error)
	inspectFuncGetCartByUserID   func(userID model.UserID)
	afterGetCartByUserIDCounter  uint64
	beforeGetCartByUserIDCounter uint64
	GetCartByUserIDMock          mCartServiceMockGetCartByUserID

	funcGetTotalPrice          func(cart *model.Cart) (u1 uint32)
	inspectFuncGetTotalPrice   func(cart *model.Cart)
	afterGetTotalPriceCounter  uint64
	beforeGetTotalPriceCounter uint64
	GetTotalPriceMock          mCartServiceMockGetTotalPrice
}

// NewCartServiceMock returns a mock for handler.CartService
func NewCartServiceMock(t minimock.Tester) *CartServiceMock {
	m := &CartServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemsToCartMock = mCartServiceMockAddItemsToCart{mock: m}
	m.AddItemsToCartMock.callArgs = []*CartServiceMockAddItemsToCartParams{}

	m.DeleteCartByUserIDMock = mCartServiceMockDeleteCartByUserID{mock: m}
	m.DeleteCartByUserIDMock.callArgs = []*CartServiceMockDeleteCartByUserIDParams{}

	m.DeleteItemsFromCartMock = mCartServiceMockDeleteItemsFromCart{mock: m}
	m.DeleteItemsFromCartMock.callArgs = []*CartServiceMockDeleteItemsFromCartParams{}

	m.GetCartByUserIDMock = mCartServiceMockGetCartByUserID{mock: m}
	m.GetCartByUserIDMock.callArgs = []*CartServiceMockGetCartByUserIDParams{}

	m.GetTotalPriceMock = mCartServiceMockGetTotalPrice{mock: m}
	m.GetTotalPriceMock.callArgs = []*CartServiceMockGetTotalPriceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartServiceMockAddItemsToCart struct {
	optional           bool
	mock               *CartServiceMock
	defaultExpectation *CartServiceMockAddItemsToCartExpectation
	expectations       []*CartServiceMockAddItemsToCartExpectation

	callArgs []*CartServiceMockAddItemsToCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartServiceMockAddItemsToCartExpectation specifies expectation struct of the CartService.AddItemsToCart
type CartServiceMockAddItemsToCartExpectation struct {
	mock      *CartServiceMock
	params    *CartServiceMockAddItemsToCartParams
	paramPtrs *CartServiceMockAddItemsToCartParamPtrs

	Counter uint64
}

// CartServiceMockAddItemsToCartParams contains parameters of the CartService.AddItemsToCart
type CartServiceMockAddItemsToCartParams struct {
	userID model.UserID
	item   model.Item
}

// CartServiceMockAddItemsToCartParamPtrs contains pointers to parameters of the CartService.AddItemsToCart
type CartServiceMockAddItemsToCartParamPtrs struct {
	userID *model.UserID
	item   *model.Item
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItemsToCart *mCartServiceMockAddItemsToCart) Optional() *mCartServiceMockAddItemsToCart {
	mmAddItemsToCart.optional = true
	return mmAddItemsToCart
}

// Expect sets up expected params for CartService.AddItemsToCart
func (mmAddItemsToCart *mCartServiceMockAddItemsToCart) Expect(userID model.UserID, item model.Item) *mCartServiceMockAddItemsToCart {
	if mmAddItemsToCart.mock.funcAddItemsToCart != nil {
		mmAddItemsToCart.mock.t.Fatalf("CartServiceMock.AddItemsToCart mock is already set by Set")
	}

	if mmAddItemsToCart.defaultExpectation == nil {
		mmAddItemsToCart.defaultExpectation = &CartServiceMockAddItemsToCartExpectation{}
	}

	if mmAddItemsToCart.defaultExpectation.paramPtrs != nil {
		mmAddItemsToCart.mock.t.Fatalf("CartServiceMock.AddItemsToCart mock is already set by ExpectParams functions")
	}

	mmAddItemsToCart.defaultExpectation.params = &CartServiceMockAddItemsToCartParams{userID, item}
	for _, e := range mmAddItemsToCart.expectations {
		if minimock.Equal(e.params, mmAddItemsToCart.defaultExpectation.params) {
			mmAddItemsToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItemsToCart.defaultExpectation.params)
		}
	}

	return mmAddItemsToCart
}

// ExpectUserIDParam1 sets up expected param userID for CartService.AddItemsToCart
func (mmAddItemsToCart *mCartServiceMockAddItemsToCart) ExpectUserIDParam1(userID model.UserID) *mCartServiceMockAddItemsToCart {
	if mmAddItemsToCart.mock.funcAddItemsToCart != nil {
		mmAddItemsToCart.mock.t.Fatalf("CartServiceMock.AddItemsToCart mock is already set by Set")
	}

	if mmAddItemsToCart.defaultExpectation == nil {
		mmAddItemsToCart.defaultExpectation = &CartServiceMockAddItemsToCartExpectation{}
	}

	if mmAddItemsToCart.defaultExpectation.params != nil {
		mmAddItemsToCart.mock.t.Fatalf("CartServiceMock.AddItemsToCart mock is already set by Expect")
	}

	if mmAddItemsToCart.defaultExpectation.paramPtrs == nil {
		mmAddItemsToCart.defaultExpectation.paramPtrs = &CartServiceMockAddItemsToCartParamPtrs{}
	}
	mmAddItemsToCart.defaultExpectation.paramPtrs.userID = &userID

	return mmAddItemsToCart
}

// ExpectItemParam2 sets up expected param item for CartService.AddItemsToCart
func (mmAddItemsToCart *mCartServiceMockAddItemsToCart) ExpectItemParam2(item model.Item) *mCartServiceMockAddItemsToCart {
	if mmAddItemsToCart.mock.funcAddItemsToCart != nil {
		mmAddItemsToCart.mock.t.Fatalf("CartServiceMock.AddItemsToCart mock is already set by Set")
	}

	if mmAddItemsToCart.defaultExpectation == nil {
		mmAddItemsToCart.defaultExpectation = &CartServiceMockAddItemsToCartExpectation{}
	}

	if mmAddItemsToCart.defaultExpectation.params != nil {
		mmAddItemsToCart.mock.t.Fatalf("CartServiceMock.AddItemsToCart mock is already set by Expect")
	}

	if mmAddItemsToCart.defaultExpectation.paramPtrs == nil {
		mmAddItemsToCart.defaultExpectation.paramPtrs = &CartServiceMockAddItemsToCartParamPtrs{}
	}
	mmAddItemsToCart.defaultExpectation.paramPtrs.item = &item

	return mmAddItemsToCart
}

// Inspect accepts an inspector function that has same arguments as the CartService.AddItemsToCart
func (mmAddItemsToCart *mCartServiceMockAddItemsToCart) Inspect(f func(userID model.UserID, item model.Item)) *mCartServiceMockAddItemsToCart {
	if mmAddItemsToCart.mock.inspectFuncAddItemsToCart != nil {
		mmAddItemsToCart.mock.t.Fatalf("Inspect function is already set for CartServiceMock.AddItemsToCart")
	}

	mmAddItemsToCart.mock.inspectFuncAddItemsToCart = f

	return mmAddItemsToCart
}

// Return sets up results that will be returned by CartService.AddItemsToCart
func (mmAddItemsToCart *mCartServiceMockAddItemsToCart) Return() *CartServiceMock {
	if mmAddItemsToCart.mock.funcAddItemsToCart != nil {
		mmAddItemsToCart.mock.t.Fatalf("CartServiceMock.AddItemsToCart mock is already set by Set")
	}

	if mmAddItemsToCart.defaultExpectation == nil {
		mmAddItemsToCart.defaultExpectation = &CartServiceMockAddItemsToCartExpectation{mock: mmAddItemsToCart.mock}
	}

	return mmAddItemsToCart.mock
}

// Set uses given function f to mock the CartService.AddItemsToCart method
func (mmAddItemsToCart *mCartServiceMockAddItemsToCart) Set(f func(userID model.UserID, item model.Item)) *CartServiceMock {
	if mmAddItemsToCart.defaultExpectation != nil {
		mmAddItemsToCart.mock.t.Fatalf("Default expectation is already set for the CartService.AddItemsToCart method")
	}

	if len(mmAddItemsToCart.expectations) > 0 {
		mmAddItemsToCart.mock.t.Fatalf("Some expectations are already set for the CartService.AddItemsToCart method")
	}

	mmAddItemsToCart.mock.funcAddItemsToCart = f
	return mmAddItemsToCart.mock
}

// Times sets number of times CartService.AddItemsToCart should be invoked
func (mmAddItemsToCart *mCartServiceMockAddItemsToCart) Times(n uint64) *mCartServiceMockAddItemsToCart {
	if n == 0 {
		mmAddItemsToCart.mock.t.Fatalf("Times of CartServiceMock.AddItemsToCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItemsToCart.expectedInvocations, n)
	return mmAddItemsToCart
}

func (mmAddItemsToCart *mCartServiceMockAddItemsToCart) invocationsDone() bool {
	if len(mmAddItemsToCart.expectations) == 0 && mmAddItemsToCart.defaultExpectation == nil && mmAddItemsToCart.mock.funcAddItemsToCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItemsToCart.mock.afterAddItemsToCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItemsToCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItemsToCart implements handler.CartService
func (mmAddItemsToCart *CartServiceMock) AddItemsToCart(userID model.UserID, item model.Item) {
	mm_atomic.AddUint64(&mmAddItemsToCart.beforeAddItemsToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItemsToCart.afterAddItemsToCartCounter, 1)

	if mmAddItemsToCart.inspectFuncAddItemsToCart != nil {
		mmAddItemsToCart.inspectFuncAddItemsToCart(userID, item)
	}

	mm_params := CartServiceMockAddItemsToCartParams{userID, item}

	// Record call args
	mmAddItemsToCart.AddItemsToCartMock.mutex.Lock()
	mmAddItemsToCart.AddItemsToCartMock.callArgs = append(mmAddItemsToCart.AddItemsToCartMock.callArgs, &mm_params)
	mmAddItemsToCart.AddItemsToCartMock.mutex.Unlock()

	for _, e := range mmAddItemsToCart.AddItemsToCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddItemsToCart.AddItemsToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItemsToCart.AddItemsToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItemsToCart.AddItemsToCartMock.defaultExpectation.params
		mm_want_ptrs := mmAddItemsToCart.AddItemsToCartMock.defaultExpectation.paramPtrs

		mm_got := CartServiceMockAddItemsToCartParams{userID, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddItemsToCart.t.Errorf("CartServiceMock.AddItemsToCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmAddItemsToCart.t.Errorf("CartServiceMock.AddItemsToCart got unexpected parameter item, want: %#v, got: %#v%s\n", *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItemsToCart.t.Errorf("CartServiceMock.AddItemsToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddItemsToCart.funcAddItemsToCart != nil {
		mmAddItemsToCart.funcAddItemsToCart(userID, item)
		return
	}
	mmAddItemsToCart.t.Fatalf("Unexpected call to CartServiceMock.AddItemsToCart. %v %v", userID, item)

}

// AddItemsToCartAfterCounter returns a count of finished CartServiceMock.AddItemsToCart invocations
func (mmAddItemsToCart *CartServiceMock) AddItemsToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItemsToCart.afterAddItemsToCartCounter)
}

// AddItemsToCartBeforeCounter returns a count of CartServiceMock.AddItemsToCart invocations
func (mmAddItemsToCart *CartServiceMock) AddItemsToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItemsToCart.beforeAddItemsToCartCounter)
}

// Calls returns a list of arguments used in each call to CartServiceMock.AddItemsToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItemsToCart *mCartServiceMockAddItemsToCart) Calls() []*CartServiceMockAddItemsToCartParams {
	mmAddItemsToCart.mutex.RLock()

	argCopy := make([]*CartServiceMockAddItemsToCartParams, len(mmAddItemsToCart.callArgs))
	copy(argCopy, mmAddItemsToCart.callArgs)

	mmAddItemsToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemsToCartDone returns true if the count of the AddItemsToCart invocations corresponds
// the number of defined expectations
func (m *CartServiceMock) MinimockAddItemsToCartDone() bool {
	if m.AddItemsToCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemsToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemsToCartMock.invocationsDone()
}

// MinimockAddItemsToCartInspect logs each unmet expectation
func (m *CartServiceMock) MinimockAddItemsToCartInspect() {
	for _, e := range m.AddItemsToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartServiceMock.AddItemsToCart with params: %#v", *e.params)
		}
	}

	afterAddItemsToCartCounter := mm_atomic.LoadUint64(&m.afterAddItemsToCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemsToCartMock.defaultExpectation != nil && afterAddItemsToCartCounter < 1 {
		if m.AddItemsToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartServiceMock.AddItemsToCart")
		} else {
			m.t.Errorf("Expected call to CartServiceMock.AddItemsToCart with params: %#v", *m.AddItemsToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItemsToCart != nil && afterAddItemsToCartCounter < 1 {
		m.t.Error("Expected call to CartServiceMock.AddItemsToCart")
	}

	if !m.AddItemsToCartMock.invocationsDone() && afterAddItemsToCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartServiceMock.AddItemsToCart but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemsToCartMock.expectedInvocations), afterAddItemsToCartCounter)
	}
}

type mCartServiceMockDeleteCartByUserID struct {
	optional           bool
	mock               *CartServiceMock
	defaultExpectation *CartServiceMockDeleteCartByUserIDExpectation
	expectations       []*CartServiceMockDeleteCartByUserIDExpectation

	callArgs []*CartServiceMockDeleteCartByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartServiceMockDeleteCartByUserIDExpectation specifies expectation struct of the CartService.DeleteCartByUserID
type CartServiceMockDeleteCartByUserIDExpectation struct {
	mock      *CartServiceMock
	params    *CartServiceMockDeleteCartByUserIDParams
	paramPtrs *CartServiceMockDeleteCartByUserIDParamPtrs

	Counter uint64
}

// CartServiceMockDeleteCartByUserIDParams contains parameters of the CartService.DeleteCartByUserID
type CartServiceMockDeleteCartByUserIDParams struct {
	userID model.UserID
}

// CartServiceMockDeleteCartByUserIDParamPtrs contains pointers to parameters of the CartService.DeleteCartByUserID
type CartServiceMockDeleteCartByUserIDParamPtrs struct {
	userID *model.UserID
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCartByUserID *mCartServiceMockDeleteCartByUserID) Optional() *mCartServiceMockDeleteCartByUserID {
	mmDeleteCartByUserID.optional = true
	return mmDeleteCartByUserID
}

// Expect sets up expected params for CartService.DeleteCartByUserID
func (mmDeleteCartByUserID *mCartServiceMockDeleteCartByUserID) Expect(userID model.UserID) *mCartServiceMockDeleteCartByUserID {
	if mmDeleteCartByUserID.mock.funcDeleteCartByUserID != nil {
		mmDeleteCartByUserID.mock.t.Fatalf("CartServiceMock.DeleteCartByUserID mock is already set by Set")
	}

	if mmDeleteCartByUserID.defaultExpectation == nil {
		mmDeleteCartByUserID.defaultExpectation = &CartServiceMockDeleteCartByUserIDExpectation{}
	}

	if mmDeleteCartByUserID.defaultExpectation.paramPtrs != nil {
		mmDeleteCartByUserID.mock.t.Fatalf("CartServiceMock.DeleteCartByUserID mock is already set by ExpectParams functions")
	}

	mmDeleteCartByUserID.defaultExpectation.params = &CartServiceMockDeleteCartByUserIDParams{userID}
	for _, e := range mmDeleteCartByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteCartByUserID.defaultExpectation.params) {
			mmDeleteCartByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCartByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteCartByUserID
}

// ExpectUserIDParam1 sets up expected param userID for CartService.DeleteCartByUserID
func (mmDeleteCartByUserID *mCartServiceMockDeleteCartByUserID) ExpectUserIDParam1(userID model.UserID) *mCartServiceMockDeleteCartByUserID {
	if mmDeleteCartByUserID.mock.funcDeleteCartByUserID != nil {
		mmDeleteCartByUserID.mock.t.Fatalf("CartServiceMock.DeleteCartByUserID mock is already set by Set")
	}

	if mmDeleteCartByUserID.defaultExpectation == nil {
		mmDeleteCartByUserID.defaultExpectation = &CartServiceMockDeleteCartByUserIDExpectation{}
	}

	if mmDeleteCartByUserID.defaultExpectation.params != nil {
		mmDeleteCartByUserID.mock.t.Fatalf("CartServiceMock.DeleteCartByUserID mock is already set by Expect")
	}

	if mmDeleteCartByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteCartByUserID.defaultExpectation.paramPtrs = &CartServiceMockDeleteCartByUserIDParamPtrs{}
	}
	mmDeleteCartByUserID.defaultExpectation.paramPtrs.userID = &userID

	return mmDeleteCartByUserID
}

// Inspect accepts an inspector function that has same arguments as the CartService.DeleteCartByUserID
func (mmDeleteCartByUserID *mCartServiceMockDeleteCartByUserID) Inspect(f func(userID model.UserID)) *mCartServiceMockDeleteCartByUserID {
	if mmDeleteCartByUserID.mock.inspectFuncDeleteCartByUserID != nil {
		mmDeleteCartByUserID.mock.t.Fatalf("Inspect function is already set for CartServiceMock.DeleteCartByUserID")
	}

	mmDeleteCartByUserID.mock.inspectFuncDeleteCartByUserID = f

	return mmDeleteCartByUserID
}

// Return sets up results that will be returned by CartService.DeleteCartByUserID
func (mmDeleteCartByUserID *mCartServiceMockDeleteCartByUserID) Return() *CartServiceMock {
	if mmDeleteCartByUserID.mock.funcDeleteCartByUserID != nil {
		mmDeleteCartByUserID.mock.t.Fatalf("CartServiceMock.DeleteCartByUserID mock is already set by Set")
	}

	if mmDeleteCartByUserID.defaultExpectation == nil {
		mmDeleteCartByUserID.defaultExpectation = &CartServiceMockDeleteCartByUserIDExpectation{mock: mmDeleteCartByUserID.mock}
	}

	return mmDeleteCartByUserID.mock
}

// Set uses given function f to mock the CartService.DeleteCartByUserID method
func (mmDeleteCartByUserID *mCartServiceMockDeleteCartByUserID) Set(f func(userID model.UserID)) *CartServiceMock {
	if mmDeleteCartByUserID.defaultExpectation != nil {
		mmDeleteCartByUserID.mock.t.Fatalf("Default expectation is already set for the CartService.DeleteCartByUserID method")
	}

	if len(mmDeleteCartByUserID.expectations) > 0 {
		mmDeleteCartByUserID.mock.t.Fatalf("Some expectations are already set for the CartService.DeleteCartByUserID method")
	}

	mmDeleteCartByUserID.mock.funcDeleteCartByUserID = f
	return mmDeleteCartByUserID.mock
}

// Times sets number of times CartService.DeleteCartByUserID should be invoked
func (mmDeleteCartByUserID *mCartServiceMockDeleteCartByUserID) Times(n uint64) *mCartServiceMockDeleteCartByUserID {
	if n == 0 {
		mmDeleteCartByUserID.mock.t.Fatalf("Times of CartServiceMock.DeleteCartByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCartByUserID.expectedInvocations, n)
	return mmDeleteCartByUserID
}

func (mmDeleteCartByUserID *mCartServiceMockDeleteCartByUserID) invocationsDone() bool {
	if len(mmDeleteCartByUserID.expectations) == 0 && mmDeleteCartByUserID.defaultExpectation == nil && mmDeleteCartByUserID.mock.funcDeleteCartByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCartByUserID.mock.afterDeleteCartByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCartByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCartByUserID implements handler.CartService
func (mmDeleteCartByUserID *CartServiceMock) DeleteCartByUserID(userID model.UserID) {
	mm_atomic.AddUint64(&mmDeleteCartByUserID.beforeDeleteCartByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCartByUserID.afterDeleteCartByUserIDCounter, 1)

	if mmDeleteCartByUserID.inspectFuncDeleteCartByUserID != nil {
		mmDeleteCartByUserID.inspectFuncDeleteCartByUserID(userID)
	}

	mm_params := CartServiceMockDeleteCartByUserIDParams{userID}

	// Record call args
	mmDeleteCartByUserID.DeleteCartByUserIDMock.mutex.Lock()
	mmDeleteCartByUserID.DeleteCartByUserIDMock.callArgs = append(mmDeleteCartByUserID.DeleteCartByUserIDMock.callArgs, &mm_params)
	mmDeleteCartByUserID.DeleteCartByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteCartByUserID.DeleteCartByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteCartByUserID.DeleteCartByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCartByUserID.DeleteCartByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCartByUserID.DeleteCartByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCartByUserID.DeleteCartByUserIDMock.defaultExpectation.paramPtrs

		mm_got := CartServiceMockDeleteCartByUserIDParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteCartByUserID.t.Errorf("CartServiceMock.DeleteCartByUserID got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCartByUserID.t.Errorf("CartServiceMock.DeleteCartByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteCartByUserID.funcDeleteCartByUserID != nil {
		mmDeleteCartByUserID.funcDeleteCartByUserID(userID)
		return
	}
	mmDeleteCartByUserID.t.Fatalf("Unexpected call to CartServiceMock.DeleteCartByUserID. %v", userID)

}

// DeleteCartByUserIDAfterCounter returns a count of finished CartServiceMock.DeleteCartByUserID invocations
func (mmDeleteCartByUserID *CartServiceMock) DeleteCartByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCartByUserID.afterDeleteCartByUserIDCounter)
}

// DeleteCartByUserIDBeforeCounter returns a count of CartServiceMock.DeleteCartByUserID invocations
func (mmDeleteCartByUserID *CartServiceMock) DeleteCartByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCartByUserID.beforeDeleteCartByUserIDCounter)
}

// Calls returns a list of arguments used in each call to CartServiceMock.DeleteCartByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCartByUserID *mCartServiceMockDeleteCartByUserID) Calls() []*CartServiceMockDeleteCartByUserIDParams {
	mmDeleteCartByUserID.mutex.RLock()

	argCopy := make([]*CartServiceMockDeleteCartByUserIDParams, len(mmDeleteCartByUserID.callArgs))
	copy(argCopy, mmDeleteCartByUserID.callArgs)

	mmDeleteCartByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartByUserIDDone returns true if the count of the DeleteCartByUserID invocations corresponds
// the number of defined expectations
func (m *CartServiceMock) MinimockDeleteCartByUserIDDone() bool {
	if m.DeleteCartByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCartByUserIDMock.invocationsDone()
}

// MinimockDeleteCartByUserIDInspect logs each unmet expectation
func (m *CartServiceMock) MinimockDeleteCartByUserIDInspect() {
	for _, e := range m.DeleteCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartServiceMock.DeleteCartByUserID with params: %#v", *e.params)
		}
	}

	afterDeleteCartByUserIDCounter := mm_atomic.LoadUint64(&m.afterDeleteCartByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartByUserIDMock.defaultExpectation != nil && afterDeleteCartByUserIDCounter < 1 {
		if m.DeleteCartByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartServiceMock.DeleteCartByUserID")
		} else {
			m.t.Errorf("Expected call to CartServiceMock.DeleteCartByUserID with params: %#v", *m.DeleteCartByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCartByUserID != nil && afterDeleteCartByUserIDCounter < 1 {
		m.t.Error("Expected call to CartServiceMock.DeleteCartByUserID")
	}

	if !m.DeleteCartByUserIDMock.invocationsDone() && afterDeleteCartByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CartServiceMock.DeleteCartByUserID but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCartByUserIDMock.expectedInvocations), afterDeleteCartByUserIDCounter)
	}
}

type mCartServiceMockDeleteItemsFromCart struct {
	optional           bool
	mock               *CartServiceMock
	defaultExpectation *CartServiceMockDeleteItemsFromCartExpectation
	expectations       []*CartServiceMockDeleteItemsFromCartExpectation

	callArgs []*CartServiceMockDeleteItemsFromCartParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartServiceMockDeleteItemsFromCartExpectation specifies expectation struct of the CartService.DeleteItemsFromCart
type CartServiceMockDeleteItemsFromCartExpectation struct {
	mock      *CartServiceMock
	params    *CartServiceMockDeleteItemsFromCartParams
	paramPtrs *CartServiceMockDeleteItemsFromCartParamPtrs

	Counter uint64
}

// CartServiceMockDeleteItemsFromCartParams contains parameters of the CartService.DeleteItemsFromCart
type CartServiceMockDeleteItemsFromCartParams struct {
	userID model.UserID
	itemID model.SkuID
}

// CartServiceMockDeleteItemsFromCartParamPtrs contains pointers to parameters of the CartService.DeleteItemsFromCart
type CartServiceMockDeleteItemsFromCartParamPtrs struct {
	userID *model.UserID
	itemID *model.SkuID
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItemsFromCart *mCartServiceMockDeleteItemsFromCart) Optional() *mCartServiceMockDeleteItemsFromCart {
	mmDeleteItemsFromCart.optional = true
	return mmDeleteItemsFromCart
}

// Expect sets up expected params for CartService.DeleteItemsFromCart
func (mmDeleteItemsFromCart *mCartServiceMockDeleteItemsFromCart) Expect(userID model.UserID, itemID model.SkuID) *mCartServiceMockDeleteItemsFromCart {
	if mmDeleteItemsFromCart.mock.funcDeleteItemsFromCart != nil {
		mmDeleteItemsFromCart.mock.t.Fatalf("CartServiceMock.DeleteItemsFromCart mock is already set by Set")
	}

	if mmDeleteItemsFromCart.defaultExpectation == nil {
		mmDeleteItemsFromCart.defaultExpectation = &CartServiceMockDeleteItemsFromCartExpectation{}
	}

	if mmDeleteItemsFromCart.defaultExpectation.paramPtrs != nil {
		mmDeleteItemsFromCart.mock.t.Fatalf("CartServiceMock.DeleteItemsFromCart mock is already set by ExpectParams functions")
	}

	mmDeleteItemsFromCart.defaultExpectation.params = &CartServiceMockDeleteItemsFromCartParams{userID, itemID}
	for _, e := range mmDeleteItemsFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteItemsFromCart.defaultExpectation.params) {
			mmDeleteItemsFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemsFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteItemsFromCart
}

// ExpectUserIDParam1 sets up expected param userID for CartService.DeleteItemsFromCart
func (mmDeleteItemsFromCart *mCartServiceMockDeleteItemsFromCart) ExpectUserIDParam1(userID model.UserID) *mCartServiceMockDeleteItemsFromCart {
	if mmDeleteItemsFromCart.mock.funcDeleteItemsFromCart != nil {
		mmDeleteItemsFromCart.mock.t.Fatalf("CartServiceMock.DeleteItemsFromCart mock is already set by Set")
	}

	if mmDeleteItemsFromCart.defaultExpectation == nil {
		mmDeleteItemsFromCart.defaultExpectation = &CartServiceMockDeleteItemsFromCartExpectation{}
	}

	if mmDeleteItemsFromCart.defaultExpectation.params != nil {
		mmDeleteItemsFromCart.mock.t.Fatalf("CartServiceMock.DeleteItemsFromCart mock is already set by Expect")
	}

	if mmDeleteItemsFromCart.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsFromCart.defaultExpectation.paramPtrs = &CartServiceMockDeleteItemsFromCartParamPtrs{}
	}
	mmDeleteItemsFromCart.defaultExpectation.paramPtrs.userID = &userID

	return mmDeleteItemsFromCart
}

// ExpectItemIDParam2 sets up expected param itemID for CartService.DeleteItemsFromCart
func (mmDeleteItemsFromCart *mCartServiceMockDeleteItemsFromCart) ExpectItemIDParam2(itemID model.SkuID) *mCartServiceMockDeleteItemsFromCart {
	if mmDeleteItemsFromCart.mock.funcDeleteItemsFromCart != nil {
		mmDeleteItemsFromCart.mock.t.Fatalf("CartServiceMock.DeleteItemsFromCart mock is already set by Set")
	}

	if mmDeleteItemsFromCart.defaultExpectation == nil {
		mmDeleteItemsFromCart.defaultExpectation = &CartServiceMockDeleteItemsFromCartExpectation{}
	}

	if mmDeleteItemsFromCart.defaultExpectation.params != nil {
		mmDeleteItemsFromCart.mock.t.Fatalf("CartServiceMock.DeleteItemsFromCart mock is already set by Expect")
	}

	if mmDeleteItemsFromCart.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsFromCart.defaultExpectation.paramPtrs = &CartServiceMockDeleteItemsFromCartParamPtrs{}
	}
	mmDeleteItemsFromCart.defaultExpectation.paramPtrs.itemID = &itemID

	return mmDeleteItemsFromCart
}

// Inspect accepts an inspector function that has same arguments as the CartService.DeleteItemsFromCart
func (mmDeleteItemsFromCart *mCartServiceMockDeleteItemsFromCart) Inspect(f func(userID model.UserID, itemID model.SkuID)) *mCartServiceMockDeleteItemsFromCart {
	if mmDeleteItemsFromCart.mock.inspectFuncDeleteItemsFromCart != nil {
		mmDeleteItemsFromCart.mock.t.Fatalf("Inspect function is already set for CartServiceMock.DeleteItemsFromCart")
	}

	mmDeleteItemsFromCart.mock.inspectFuncDeleteItemsFromCart = f

	return mmDeleteItemsFromCart
}

// Return sets up results that will be returned by CartService.DeleteItemsFromCart
func (mmDeleteItemsFromCart *mCartServiceMockDeleteItemsFromCart) Return() *CartServiceMock {
	if mmDeleteItemsFromCart.mock.funcDeleteItemsFromCart != nil {
		mmDeleteItemsFromCart.mock.t.Fatalf("CartServiceMock.DeleteItemsFromCart mock is already set by Set")
	}

	if mmDeleteItemsFromCart.defaultExpectation == nil {
		mmDeleteItemsFromCart.defaultExpectation = &CartServiceMockDeleteItemsFromCartExpectation{mock: mmDeleteItemsFromCart.mock}
	}

	return mmDeleteItemsFromCart.mock
}

// Set uses given function f to mock the CartService.DeleteItemsFromCart method
func (mmDeleteItemsFromCart *mCartServiceMockDeleteItemsFromCart) Set(f func(userID model.UserID, itemID model.SkuID)) *CartServiceMock {
	if mmDeleteItemsFromCart.defaultExpectation != nil {
		mmDeleteItemsFromCart.mock.t.Fatalf("Default expectation is already set for the CartService.DeleteItemsFromCart method")
	}

	if len(mmDeleteItemsFromCart.expectations) > 0 {
		mmDeleteItemsFromCart.mock.t.Fatalf("Some expectations are already set for the CartService.DeleteItemsFromCart method")
	}

	mmDeleteItemsFromCart.mock.funcDeleteItemsFromCart = f
	return mmDeleteItemsFromCart.mock
}

// Times sets number of times CartService.DeleteItemsFromCart should be invoked
func (mmDeleteItemsFromCart *mCartServiceMockDeleteItemsFromCart) Times(n uint64) *mCartServiceMockDeleteItemsFromCart {
	if n == 0 {
		mmDeleteItemsFromCart.mock.t.Fatalf("Times of CartServiceMock.DeleteItemsFromCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItemsFromCart.expectedInvocations, n)
	return mmDeleteItemsFromCart
}

func (mmDeleteItemsFromCart *mCartServiceMockDeleteItemsFromCart) invocationsDone() bool {
	if len(mmDeleteItemsFromCart.expectations) == 0 && mmDeleteItemsFromCart.defaultExpectation == nil && mmDeleteItemsFromCart.mock.funcDeleteItemsFromCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItemsFromCart.mock.afterDeleteItemsFromCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItemsFromCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItemsFromCart implements handler.CartService
func (mmDeleteItemsFromCart *CartServiceMock) DeleteItemsFromCart(userID model.UserID, itemID model.SkuID) {
	mm_atomic.AddUint64(&mmDeleteItemsFromCart.beforeDeleteItemsFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemsFromCart.afterDeleteItemsFromCartCounter, 1)

	if mmDeleteItemsFromCart.inspectFuncDeleteItemsFromCart != nil {
		mmDeleteItemsFromCart.inspectFuncDeleteItemsFromCart(userID, itemID)
	}

	mm_params := CartServiceMockDeleteItemsFromCartParams{userID, itemID}

	// Record call args
	mmDeleteItemsFromCart.DeleteItemsFromCartMock.mutex.Lock()
	mmDeleteItemsFromCart.DeleteItemsFromCartMock.callArgs = append(mmDeleteItemsFromCart.DeleteItemsFromCartMock.callArgs, &mm_params)
	mmDeleteItemsFromCart.DeleteItemsFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteItemsFromCart.DeleteItemsFromCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteItemsFromCart.DeleteItemsFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemsFromCart.DeleteItemsFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemsFromCart.DeleteItemsFromCartMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItemsFromCart.DeleteItemsFromCartMock.defaultExpectation.paramPtrs

		mm_got := CartServiceMockDeleteItemsFromCartParams{userID, itemID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItemsFromCart.t.Errorf("CartServiceMock.DeleteItemsFromCart got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.itemID != nil && !minimock.Equal(*mm_want_ptrs.itemID, mm_got.itemID) {
				mmDeleteItemsFromCart.t.Errorf("CartServiceMock.DeleteItemsFromCart got unexpected parameter itemID, want: %#v, got: %#v%s\n", *mm_want_ptrs.itemID, mm_got.itemID, minimock.Diff(*mm_want_ptrs.itemID, mm_got.itemID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemsFromCart.t.Errorf("CartServiceMock.DeleteItemsFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteItemsFromCart.funcDeleteItemsFromCart != nil {
		mmDeleteItemsFromCart.funcDeleteItemsFromCart(userID, itemID)
		return
	}
	mmDeleteItemsFromCart.t.Fatalf("Unexpected call to CartServiceMock.DeleteItemsFromCart. %v %v", userID, itemID)

}

// DeleteItemsFromCartAfterCounter returns a count of finished CartServiceMock.DeleteItemsFromCart invocations
func (mmDeleteItemsFromCart *CartServiceMock) DeleteItemsFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsFromCart.afterDeleteItemsFromCartCounter)
}

// DeleteItemsFromCartBeforeCounter returns a count of CartServiceMock.DeleteItemsFromCart invocations
func (mmDeleteItemsFromCart *CartServiceMock) DeleteItemsFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsFromCart.beforeDeleteItemsFromCartCounter)
}

// Calls returns a list of arguments used in each call to CartServiceMock.DeleteItemsFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemsFromCart *mCartServiceMockDeleteItemsFromCart) Calls() []*CartServiceMockDeleteItemsFromCartParams {
	mmDeleteItemsFromCart.mutex.RLock()

	argCopy := make([]*CartServiceMockDeleteItemsFromCartParams, len(mmDeleteItemsFromCart.callArgs))
	copy(argCopy, mmDeleteItemsFromCart.callArgs)

	mmDeleteItemsFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsFromCartDone returns true if the count of the DeleteItemsFromCart invocations corresponds
// the number of defined expectations
func (m *CartServiceMock) MinimockDeleteItemsFromCartDone() bool {
	if m.DeleteItemsFromCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemsFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemsFromCartMock.invocationsDone()
}

// MinimockDeleteItemsFromCartInspect logs each unmet expectation
func (m *CartServiceMock) MinimockDeleteItemsFromCartInspect() {
	for _, e := range m.DeleteItemsFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartServiceMock.DeleteItemsFromCart with params: %#v", *e.params)
		}
	}

	afterDeleteItemsFromCartCounter := mm_atomic.LoadUint64(&m.afterDeleteItemsFromCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsFromCartMock.defaultExpectation != nil && afterDeleteItemsFromCartCounter < 1 {
		if m.DeleteItemsFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartServiceMock.DeleteItemsFromCart")
		} else {
			m.t.Errorf("Expected call to CartServiceMock.DeleteItemsFromCart with params: %#v", *m.DeleteItemsFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsFromCart != nil && afterDeleteItemsFromCartCounter < 1 {
		m.t.Error("Expected call to CartServiceMock.DeleteItemsFromCart")
	}

	if !m.DeleteItemsFromCartMock.invocationsDone() && afterDeleteItemsFromCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartServiceMock.DeleteItemsFromCart but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemsFromCartMock.expectedInvocations), afterDeleteItemsFromCartCounter)
	}
}

type mCartServiceMockGetCartByUserID struct {
	optional           bool
	mock               *CartServiceMock
	defaultExpectation *CartServiceMockGetCartByUserIDExpectation
	expectations       []*CartServiceMockGetCartByUserIDExpectation

	callArgs []*CartServiceMockGetCartByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartServiceMockGetCartByUserIDExpectation specifies expectation struct of the CartService.GetCartByUserID
type CartServiceMockGetCartByUserIDExpectation struct {
	mock      *CartServiceMock
	params    *CartServiceMockGetCartByUserIDParams
	paramPtrs *CartServiceMockGetCartByUserIDParamPtrs
	results   *CartServiceMockGetCartByUserIDResults
	Counter   uint64
}

// CartServiceMockGetCartByUserIDParams contains parameters of the CartService.GetCartByUserID
type CartServiceMockGetCartByUserIDParams struct {
	userID model.UserID
}

// CartServiceMockGetCartByUserIDParamPtrs contains pointers to parameters of the CartService.GetCartByUserID
type CartServiceMockGetCartByUserIDParamPtrs struct {
	userID *model.UserID
}

// CartServiceMockGetCartByUserIDResults contains results of the CartService.GetCartByUserID
type CartServiceMockGetCartByUserIDResults struct {
	cp1 *model.Cart
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCartByUserID *mCartServiceMockGetCartByUserID) Optional() *mCartServiceMockGetCartByUserID {
	mmGetCartByUserID.optional = true
	return mmGetCartByUserID
}

// Expect sets up expected params for CartService.GetCartByUserID
func (mmGetCartByUserID *mCartServiceMockGetCartByUserID) Expect(userID model.UserID) *mCartServiceMockGetCartByUserID {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("CartServiceMock.GetCartByUserID mock is already set by Set")
	}

	if mmGetCartByUserID.defaultExpectation == nil {
		mmGetCartByUserID.defaultExpectation = &CartServiceMockGetCartByUserIDExpectation{}
	}

	if mmGetCartByUserID.defaultExpectation.paramPtrs != nil {
		mmGetCartByUserID.mock.t.Fatalf("CartServiceMock.GetCartByUserID mock is already set by ExpectParams functions")
	}

	mmGetCartByUserID.defaultExpectation.params = &CartServiceMockGetCartByUserIDParams{userID}
	for _, e := range mmGetCartByUserID.expectations {
		if minimock.Equal(e.params, mmGetCartByUserID.defaultExpectation.params) {
			mmGetCartByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartByUserID.defaultExpectation.params)
		}
	}

	return mmGetCartByUserID
}

// ExpectUserIDParam1 sets up expected param userID for CartService.GetCartByUserID
func (mmGetCartByUserID *mCartServiceMockGetCartByUserID) ExpectUserIDParam1(userID model.UserID) *mCartServiceMockGetCartByUserID {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("CartServiceMock.GetCartByUserID mock is already set by Set")
	}

	if mmGetCartByUserID.defaultExpectation == nil {
		mmGetCartByUserID.defaultExpectation = &CartServiceMockGetCartByUserIDExpectation{}
	}

	if mmGetCartByUserID.defaultExpectation.params != nil {
		mmGetCartByUserID.mock.t.Fatalf("CartServiceMock.GetCartByUserID mock is already set by Expect")
	}

	if mmGetCartByUserID.defaultExpectation.paramPtrs == nil {
		mmGetCartByUserID.defaultExpectation.paramPtrs = &CartServiceMockGetCartByUserIDParamPtrs{}
	}
	mmGetCartByUserID.defaultExpectation.paramPtrs.userID = &userID

	return mmGetCartByUserID
}

// Inspect accepts an inspector function that has same arguments as the CartService.GetCartByUserID
func (mmGetCartByUserID *mCartServiceMockGetCartByUserID) Inspect(f func(userID model.UserID)) *mCartServiceMockGetCartByUserID {
	if mmGetCartByUserID.mock.inspectFuncGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("Inspect function is already set for CartServiceMock.GetCartByUserID")
	}

	mmGetCartByUserID.mock.inspectFuncGetCartByUserID = f

	return mmGetCartByUserID
}

// Return sets up results that will be returned by CartService.GetCartByUserID
func (mmGetCartByUserID *mCartServiceMockGetCartByUserID) Return(cp1 *model.Cart, err error) *CartServiceMock {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("CartServiceMock.GetCartByUserID mock is already set by Set")
	}

	if mmGetCartByUserID.defaultExpectation == nil {
		mmGetCartByUserID.defaultExpectation = &CartServiceMockGetCartByUserIDExpectation{mock: mmGetCartByUserID.mock}
	}
	mmGetCartByUserID.defaultExpectation.results = &CartServiceMockGetCartByUserIDResults{cp1, err}
	return mmGetCartByUserID.mock
}

// Set uses given function f to mock the CartService.GetCartByUserID method
func (mmGetCartByUserID *mCartServiceMockGetCartByUserID) Set(f func(userID model.UserID) (cp1 *model.Cart, err error)) *CartServiceMock {
	if mmGetCartByUserID.defaultExpectation != nil {
		mmGetCartByUserID.mock.t.Fatalf("Default expectation is already set for the CartService.GetCartByUserID method")
	}

	if len(mmGetCartByUserID.expectations) > 0 {
		mmGetCartByUserID.mock.t.Fatalf("Some expectations are already set for the CartService.GetCartByUserID method")
	}

	mmGetCartByUserID.mock.funcGetCartByUserID = f
	return mmGetCartByUserID.mock
}

// When sets expectation for the CartService.GetCartByUserID which will trigger the result defined by the following
// Then helper
func (mmGetCartByUserID *mCartServiceMockGetCartByUserID) When(userID model.UserID) *CartServiceMockGetCartByUserIDExpectation {
	if mmGetCartByUserID.mock.funcGetCartByUserID != nil {
		mmGetCartByUserID.mock.t.Fatalf("CartServiceMock.GetCartByUserID mock is already set by Set")
	}

	expectation := &CartServiceMockGetCartByUserIDExpectation{
		mock:   mmGetCartByUserID.mock,
		params: &CartServiceMockGetCartByUserIDParams{userID},
	}
	mmGetCartByUserID.expectations = append(mmGetCartByUserID.expectations, expectation)
	return expectation
}

// Then sets up CartService.GetCartByUserID return parameters for the expectation previously defined by the When method
func (e *CartServiceMockGetCartByUserIDExpectation) Then(cp1 *model.Cart, err error) *CartServiceMock {
	e.results = &CartServiceMockGetCartByUserIDResults{cp1, err}
	return e.mock
}

// Times sets number of times CartService.GetCartByUserID should be invoked
func (mmGetCartByUserID *mCartServiceMockGetCartByUserID) Times(n uint64) *mCartServiceMockGetCartByUserID {
	if n == 0 {
		mmGetCartByUserID.mock.t.Fatalf("Times of CartServiceMock.GetCartByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCartByUserID.expectedInvocations, n)
	return mmGetCartByUserID
}

func (mmGetCartByUserID *mCartServiceMockGetCartByUserID) invocationsDone() bool {
	if len(mmGetCartByUserID.expectations) == 0 && mmGetCartByUserID.defaultExpectation == nil && mmGetCartByUserID.mock.funcGetCartByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCartByUserID.mock.afterGetCartByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCartByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCartByUserID implements handler.CartService
func (mmGetCartByUserID *CartServiceMock) GetCartByUserID(userID model.UserID) (cp1 *model.Cart, err error) {
	mm_atomic.AddUint64(&mmGetCartByUserID.beforeGetCartByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartByUserID.afterGetCartByUserIDCounter, 1)

	if mmGetCartByUserID.inspectFuncGetCartByUserID != nil {
		mmGetCartByUserID.inspectFuncGetCartByUserID(userID)
	}

	mm_params := CartServiceMockGetCartByUserIDParams{userID}

	// Record call args
	mmGetCartByUserID.GetCartByUserIDMock.mutex.Lock()
	mmGetCartByUserID.GetCartByUserIDMock.callArgs = append(mmGetCartByUserID.GetCartByUserIDMock.callArgs, &mm_params)
	mmGetCartByUserID.GetCartByUserIDMock.mutex.Unlock()

	for _, e := range mmGetCartByUserID.GetCartByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.paramPtrs

		mm_got := CartServiceMockGetCartByUserIDParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCartByUserID.t.Errorf("CartServiceMock.GetCartByUserID got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartByUserID.t.Errorf("CartServiceMock.GetCartByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartByUserID.GetCartByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartByUserID.t.Fatal("No results are set for the CartServiceMock.GetCartByUserID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCartByUserID.funcGetCartByUserID != nil {
		return mmGetCartByUserID.funcGetCartByUserID(userID)
	}
	mmGetCartByUserID.t.Fatalf("Unexpected call to CartServiceMock.GetCartByUserID. %v", userID)
	return
}

// GetCartByUserIDAfterCounter returns a count of finished CartServiceMock.GetCartByUserID invocations
func (mmGetCartByUserID *CartServiceMock) GetCartByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartByUserID.afterGetCartByUserIDCounter)
}

// GetCartByUserIDBeforeCounter returns a count of CartServiceMock.GetCartByUserID invocations
func (mmGetCartByUserID *CartServiceMock) GetCartByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartByUserID.beforeGetCartByUserIDCounter)
}

// Calls returns a list of arguments used in each call to CartServiceMock.GetCartByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartByUserID *mCartServiceMockGetCartByUserID) Calls() []*CartServiceMockGetCartByUserIDParams {
	mmGetCartByUserID.mutex.RLock()

	argCopy := make([]*CartServiceMockGetCartByUserIDParams, len(mmGetCartByUserID.callArgs))
	copy(argCopy, mmGetCartByUserID.callArgs)

	mmGetCartByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartByUserIDDone returns true if the count of the GetCartByUserID invocations corresponds
// the number of defined expectations
func (m *CartServiceMock) MinimockGetCartByUserIDDone() bool {
	if m.GetCartByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartByUserIDMock.invocationsDone()
}

// MinimockGetCartByUserIDInspect logs each unmet expectation
func (m *CartServiceMock) MinimockGetCartByUserIDInspect() {
	for _, e := range m.GetCartByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartServiceMock.GetCartByUserID with params: %#v", *e.params)
		}
	}

	afterGetCartByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetCartByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartByUserIDMock.defaultExpectation != nil && afterGetCartByUserIDCounter < 1 {
		if m.GetCartByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartServiceMock.GetCartByUserID")
		} else {
			m.t.Errorf("Expected call to CartServiceMock.GetCartByUserID with params: %#v", *m.GetCartByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartByUserID != nil && afterGetCartByUserIDCounter < 1 {
		m.t.Error("Expected call to CartServiceMock.GetCartByUserID")
	}

	if !m.GetCartByUserIDMock.invocationsDone() && afterGetCartByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CartServiceMock.GetCartByUserID but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartByUserIDMock.expectedInvocations), afterGetCartByUserIDCounter)
	}
}

type mCartServiceMockGetTotalPrice struct {
	optional           bool
	mock               *CartServiceMock
	defaultExpectation *CartServiceMockGetTotalPriceExpectation
	expectations       []*CartServiceMockGetTotalPriceExpectation

	callArgs []*CartServiceMockGetTotalPriceParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CartServiceMockGetTotalPriceExpectation specifies expectation struct of the CartService.GetTotalPrice
type CartServiceMockGetTotalPriceExpectation struct {
	mock      *CartServiceMock
	params    *CartServiceMockGetTotalPriceParams
	paramPtrs *CartServiceMockGetTotalPriceParamPtrs
	results   *CartServiceMockGetTotalPriceResults
	Counter   uint64
}

// CartServiceMockGetTotalPriceParams contains parameters of the CartService.GetTotalPrice
type CartServiceMockGetTotalPriceParams struct {
	cart *model.Cart
}

// CartServiceMockGetTotalPriceParamPtrs contains pointers to parameters of the CartService.GetTotalPrice
type CartServiceMockGetTotalPriceParamPtrs struct {
	cart **model.Cart
}

// CartServiceMockGetTotalPriceResults contains results of the CartService.GetTotalPrice
type CartServiceMockGetTotalPriceResults struct {
	u1 uint32
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTotalPrice *mCartServiceMockGetTotalPrice) Optional() *mCartServiceMockGetTotalPrice {
	mmGetTotalPrice.optional = true
	return mmGetTotalPrice
}

// Expect sets up expected params for CartService.GetTotalPrice
func (mmGetTotalPrice *mCartServiceMockGetTotalPrice) Expect(cart *model.Cart) *mCartServiceMockGetTotalPrice {
	if mmGetTotalPrice.mock.funcGetTotalPrice != nil {
		mmGetTotalPrice.mock.t.Fatalf("CartServiceMock.GetTotalPrice mock is already set by Set")
	}

	if mmGetTotalPrice.defaultExpectation == nil {
		mmGetTotalPrice.defaultExpectation = &CartServiceMockGetTotalPriceExpectation{}
	}

	if mmGetTotalPrice.defaultExpectation.paramPtrs != nil {
		mmGetTotalPrice.mock.t.Fatalf("CartServiceMock.GetTotalPrice mock is already set by ExpectParams functions")
	}

	mmGetTotalPrice.defaultExpectation.params = &CartServiceMockGetTotalPriceParams{cart}
	for _, e := range mmGetTotalPrice.expectations {
		if minimock.Equal(e.params, mmGetTotalPrice.defaultExpectation.params) {
			mmGetTotalPrice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTotalPrice.defaultExpectation.params)
		}
	}

	return mmGetTotalPrice
}

// ExpectCartParam1 sets up expected param cart for CartService.GetTotalPrice
func (mmGetTotalPrice *mCartServiceMockGetTotalPrice) ExpectCartParam1(cart *model.Cart) *mCartServiceMockGetTotalPrice {
	if mmGetTotalPrice.mock.funcGetTotalPrice != nil {
		mmGetTotalPrice.mock.t.Fatalf("CartServiceMock.GetTotalPrice mock is already set by Set")
	}

	if mmGetTotalPrice.defaultExpectation == nil {
		mmGetTotalPrice.defaultExpectation = &CartServiceMockGetTotalPriceExpectation{}
	}

	if mmGetTotalPrice.defaultExpectation.params != nil {
		mmGetTotalPrice.mock.t.Fatalf("CartServiceMock.GetTotalPrice mock is already set by Expect")
	}

	if mmGetTotalPrice.defaultExpectation.paramPtrs == nil {
		mmGetTotalPrice.defaultExpectation.paramPtrs = &CartServiceMockGetTotalPriceParamPtrs{}
	}
	mmGetTotalPrice.defaultExpectation.paramPtrs.cart = &cart

	return mmGetTotalPrice
}

// Inspect accepts an inspector function that has same arguments as the CartService.GetTotalPrice
func (mmGetTotalPrice *mCartServiceMockGetTotalPrice) Inspect(f func(cart *model.Cart)) *mCartServiceMockGetTotalPrice {
	if mmGetTotalPrice.mock.inspectFuncGetTotalPrice != nil {
		mmGetTotalPrice.mock.t.Fatalf("Inspect function is already set for CartServiceMock.GetTotalPrice")
	}

	mmGetTotalPrice.mock.inspectFuncGetTotalPrice = f

	return mmGetTotalPrice
}

// Return sets up results that will be returned by CartService.GetTotalPrice
func (mmGetTotalPrice *mCartServiceMockGetTotalPrice) Return(u1 uint32) *CartServiceMock {
	if mmGetTotalPrice.mock.funcGetTotalPrice != nil {
		mmGetTotalPrice.mock.t.Fatalf("CartServiceMock.GetTotalPrice mock is already set by Set")
	}

	if mmGetTotalPrice.defaultExpectation == nil {
		mmGetTotalPrice.defaultExpectation = &CartServiceMockGetTotalPriceExpectation{mock: mmGetTotalPrice.mock}
	}
	mmGetTotalPrice.defaultExpectation.results = &CartServiceMockGetTotalPriceResults{u1}
	return mmGetTotalPrice.mock
}

// Set uses given function f to mock the CartService.GetTotalPrice method
func (mmGetTotalPrice *mCartServiceMockGetTotalPrice) Set(f func(cart *model.Cart) (u1 uint32)) *CartServiceMock {
	if mmGetTotalPrice.defaultExpectation != nil {
		mmGetTotalPrice.mock.t.Fatalf("Default expectation is already set for the CartService.GetTotalPrice method")
	}

	if len(mmGetTotalPrice.expectations) > 0 {
		mmGetTotalPrice.mock.t.Fatalf("Some expectations are already set for the CartService.GetTotalPrice method")
	}

	mmGetTotalPrice.mock.funcGetTotalPrice = f
	return mmGetTotalPrice.mock
}

// When sets expectation for the CartService.GetTotalPrice which will trigger the result defined by the following
// Then helper
func (mmGetTotalPrice *mCartServiceMockGetTotalPrice) When(cart *model.Cart) *CartServiceMockGetTotalPriceExpectation {
	if mmGetTotalPrice.mock.funcGetTotalPrice != nil {
		mmGetTotalPrice.mock.t.Fatalf("CartServiceMock.GetTotalPrice mock is already set by Set")
	}

	expectation := &CartServiceMockGetTotalPriceExpectation{
		mock:   mmGetTotalPrice.mock,
		params: &CartServiceMockGetTotalPriceParams{cart},
	}
	mmGetTotalPrice.expectations = append(mmGetTotalPrice.expectations, expectation)
	return expectation
}

// Then sets up CartService.GetTotalPrice return parameters for the expectation previously defined by the When method
func (e *CartServiceMockGetTotalPriceExpectation) Then(u1 uint32) *CartServiceMock {
	e.results = &CartServiceMockGetTotalPriceResults{u1}
	return e.mock
}

// Times sets number of times CartService.GetTotalPrice should be invoked
func (mmGetTotalPrice *mCartServiceMockGetTotalPrice) Times(n uint64) *mCartServiceMockGetTotalPrice {
	if n == 0 {
		mmGetTotalPrice.mock.t.Fatalf("Times of CartServiceMock.GetTotalPrice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTotalPrice.expectedInvocations, n)
	return mmGetTotalPrice
}

func (mmGetTotalPrice *mCartServiceMockGetTotalPrice) invocationsDone() bool {
	if len(mmGetTotalPrice.expectations) == 0 && mmGetTotalPrice.defaultExpectation == nil && mmGetTotalPrice.mock.funcGetTotalPrice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTotalPrice.mock.afterGetTotalPriceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTotalPrice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTotalPrice implements handler.CartService
func (mmGetTotalPrice *CartServiceMock) GetTotalPrice(cart *model.Cart) (u1 uint32) {
	mm_atomic.AddUint64(&mmGetTotalPrice.beforeGetTotalPriceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTotalPrice.afterGetTotalPriceCounter, 1)

	if mmGetTotalPrice.inspectFuncGetTotalPrice != nil {
		mmGetTotalPrice.inspectFuncGetTotalPrice(cart)
	}

	mm_params := CartServiceMockGetTotalPriceParams{cart}

	// Record call args
	mmGetTotalPrice.GetTotalPriceMock.mutex.Lock()
	mmGetTotalPrice.GetTotalPriceMock.callArgs = append(mmGetTotalPrice.GetTotalPriceMock.callArgs, &mm_params)
	mmGetTotalPrice.GetTotalPriceMock.mutex.Unlock()

	for _, e := range mmGetTotalPrice.GetTotalPriceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1
		}
	}

	if mmGetTotalPrice.GetTotalPriceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTotalPrice.GetTotalPriceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTotalPrice.GetTotalPriceMock.defaultExpectation.params
		mm_want_ptrs := mmGetTotalPrice.GetTotalPriceMock.defaultExpectation.paramPtrs

		mm_got := CartServiceMockGetTotalPriceParams{cart}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.cart != nil && !minimock.Equal(*mm_want_ptrs.cart, mm_got.cart) {
				mmGetTotalPrice.t.Errorf("CartServiceMock.GetTotalPrice got unexpected parameter cart, want: %#v, got: %#v%s\n", *mm_want_ptrs.cart, mm_got.cart, minimock.Diff(*mm_want_ptrs.cart, mm_got.cart))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTotalPrice.t.Errorf("CartServiceMock.GetTotalPrice got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTotalPrice.GetTotalPriceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTotalPrice.t.Fatal("No results are set for the CartServiceMock.GetTotalPrice")
		}
		return (*mm_results).u1
	}
	if mmGetTotalPrice.funcGetTotalPrice != nil {
		return mmGetTotalPrice.funcGetTotalPrice(cart)
	}
	mmGetTotalPrice.t.Fatalf("Unexpected call to CartServiceMock.GetTotalPrice. %v", cart)
	return
}

// GetTotalPriceAfterCounter returns a count of finished CartServiceMock.GetTotalPrice invocations
func (mmGetTotalPrice *CartServiceMock) GetTotalPriceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalPrice.afterGetTotalPriceCounter)
}

// GetTotalPriceBeforeCounter returns a count of CartServiceMock.GetTotalPrice invocations
func (mmGetTotalPrice *CartServiceMock) GetTotalPriceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTotalPrice.beforeGetTotalPriceCounter)
}

// Calls returns a list of arguments used in each call to CartServiceMock.GetTotalPrice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTotalPrice *mCartServiceMockGetTotalPrice) Calls() []*CartServiceMockGetTotalPriceParams {
	mmGetTotalPrice.mutex.RLock()

	argCopy := make([]*CartServiceMockGetTotalPriceParams, len(mmGetTotalPrice.callArgs))
	copy(argCopy, mmGetTotalPrice.callArgs)

	mmGetTotalPrice.mutex.RUnlock()

	return argCopy
}

// MinimockGetTotalPriceDone returns true if the count of the GetTotalPrice invocations corresponds
// the number of defined expectations
func (m *CartServiceMock) MinimockGetTotalPriceDone() bool {
	if m.GetTotalPriceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTotalPriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTotalPriceMock.invocationsDone()
}

// MinimockGetTotalPriceInspect logs each unmet expectation
func (m *CartServiceMock) MinimockGetTotalPriceInspect() {
	for _, e := range m.GetTotalPriceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartServiceMock.GetTotalPrice with params: %#v", *e.params)
		}
	}

	afterGetTotalPriceCounter := mm_atomic.LoadUint64(&m.afterGetTotalPriceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTotalPriceMock.defaultExpectation != nil && afterGetTotalPriceCounter < 1 {
		if m.GetTotalPriceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartServiceMock.GetTotalPrice")
		} else {
			m.t.Errorf("Expected call to CartServiceMock.GetTotalPrice with params: %#v", *m.GetTotalPriceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTotalPrice != nil && afterGetTotalPriceCounter < 1 {
		m.t.Error("Expected call to CartServiceMock.GetTotalPrice")
	}

	if !m.GetTotalPriceMock.invocationsDone() && afterGetTotalPriceCounter > 0 {
		m.t.Errorf("Expected %d calls to CartServiceMock.GetTotalPrice but found %d calls",
			mm_atomic.LoadUint64(&m.GetTotalPriceMock.expectedInvocations), afterGetTotalPriceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemsToCartInspect()

			m.MinimockDeleteCartByUserIDInspect()

			m.MinimockDeleteItemsFromCartInspect()

			m.MinimockGetCartByUserIDInspect()

			m.MinimockGetTotalPriceInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemsToCartDone() &&
		m.MinimockDeleteCartByUserIDDone() &&
		m.MinimockDeleteItemsFromCartDone() &&
		m.MinimockGetCartByUserIDDone() &&
		m.MinimockGetTotalPriceDone()
}
